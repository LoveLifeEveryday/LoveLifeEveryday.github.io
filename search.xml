<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>8.7 平衡二叉树</title>
      <link href="/2019/11/21/8.7-ping-heng-er-cha-shu/"/>
      <url>/2019/11/21/8.7-ping-heng-er-cha-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="8-7-平衡二叉树"><a href="#8-7-平衡二叉树" class="headerlink" title="8.7 平衡二叉树"></a>8.7 平衡二叉树</h1><blockquote><p>二叉排序树如果不平衡的话，效率会高吗？当然不会</p></blockquote><h2 id="什么是平衡二叉树？"><a href="#什么是平衡二叉树？" class="headerlink" title="什么是平衡二叉树？"></a>什么是平衡二叉树？</h2><p>是一种<strong>二叉排序树</strong>，当中每个节点的<strong>左子树和右子树的高度差至多等于1</strong>.</p><h2 id="什么是平衡因子BF？"><a href="#什么是平衡因子BF？" class="headerlink" title="什么是平衡因子BF？"></a>什么是平衡因子BF？</h2><p>二叉树上节点的<strong>左子树深度减去右子树深度</strong>的值</p><h2 id="什么是最小不平衡树呢？"><a href="#什么是最小不平衡树呢？" class="headerlink" title="什么是最小不平衡树呢？"></a>什么是最小不平衡树呢？</h2><p>距离<strong>插入节点</strong>最<strong>近</strong>的。且<strong>平衡因子的绝对值大于1</strong>的节点为根的子树。<br>下图中，新插入节点37时。距离它近期的平衡因子绝对值超过1的节点是58。所以从58开始下面的子树为最小不平衡子树。</p><p><img src="https://s2.ax1x.com/2019/11/15/Ma25KP.png" alt="Ma25KP.png"></p><h2 id="8-7-1-实现原理"><a href="#8-7-1-实现原理" class="headerlink" title="8.7.1 实现原理"></a>8.7.1 实现原理</h2><h3 id="1-什么是左旋，右旋，双旋"><a href="#1-什么是左旋，右旋，双旋" class="headerlink" title="1.什么是左旋，右旋，双旋"></a>1.什么是左旋，右旋，双旋</h3><p>原理：其实就是利用左旋，右旋，双旋，进行二叉树的调整，</p><p>当BF&gt;1就右旋，反之左旋</p><p>什么是<strong>左旋</strong>？</p><p>其实就是将要旋转的结点B，<strong>左孩子A与它断开</strong>，然后旋转后，A再接到旋转后的B的左孩子下面，作为B的左孩子的右孩子</p><p><img src="https://files.jb51.net/file_images/article/201901/2019110153603213.gif?2019010153616" alt="img"></p><p>同理右旋</p><p><strong>双旋</strong>分为<strong>先左后右双旋转</strong>和<strong>先右后左双旋转</strong>，具体情况具体分析，下面的例子是先左后右双旋转的</p><p><img src="https://files.jb51.net/file_images/article/201901/2019110153648046.png?201901015370" alt="img"></p><h2 id="8-7-2-平衡二叉树的实现算法"><a href="#8-7-2-平衡二叉树的实现算法" class="headerlink" title="8.7.2 平衡二叉树的实现算法"></a>8.7.2 平衡二叉树的实现算法</h2><h3 id="1-平衡二叉树的结构"><a href="#1-平衡二叉树的结构" class="headerlink" title="1.平衡二叉树的结构"></a>1.平衡二叉树的结构</h3><p>其实就是相对于二叉排序树来说<strong>多了个平衡因子</strong></p><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span>  <span class="token keyword">struct</span> BiTNode <span class="token comment" spellcheck="true">/* 结点结构 */</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> data<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 结点数据 */</span>    <span class="token keyword">int</span> bf<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/*  结点的平衡因子 */</span>     <span class="token keyword">struct</span> BiTNode <span class="token operator">*</span>lchild<span class="token punctuation">,</span> <span class="token operator">*</span>rchild<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 左右孩子指针 */</span><span class="token punctuation">}</span> BiTNode<span class="token punctuation">,</span> <span class="token operator">*</span>BiTree<span class="token punctuation">;</span></code></pre><h3 id="2-右旋操作"><a href="#2-右旋操作" class="headerlink" title="2.右旋操作"></a>2.右旋操作</h3><pre class=" language-c"><code class="language-c">    <span class="token comment" spellcheck="true">/* 对以p为根的二叉排序树作右旋处理。 */</span><span class="token comment" spellcheck="true">/* 处理之后p指向新的树根结点。即旋转处理之前的左子树的根结点 */</span><span class="token keyword">void</span> <span class="token function">R_Rotate</span><span class="token punctuation">(</span>BiTree <span class="token operator">*</span>P<span class="token punctuation">)</span><span class="token punctuation">{</span>     BiTree L<span class="token punctuation">;</span>    L<span class="token operator">=</span><span class="token punctuation">(</span><span class="token operator">*</span>P<span class="token punctuation">)</span><span class="token operator">-></span>lchild<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/*  L指向P的左子树根结点 */</span>     <span class="token punctuation">(</span><span class="token operator">*</span>P<span class="token punctuation">)</span><span class="token operator">-></span>lchild<span class="token operator">=</span>L<span class="token operator">-></span>rchild<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/*  L的右子树挂接为P的左子树 */</span>     L<span class="token operator">-></span>rchild<span class="token operator">=</span><span class="token punctuation">(</span><span class="token operator">*</span>P<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">*</span>P<span class="token operator">=</span>L<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/*  P指向新的根结点 */</span> <span class="token punctuation">}</span></code></pre><p><img src="https://s2.ax1x.com/2019/11/15/Ma2O8s.png" alt="Ma2O8s.png"></p><p>左旋操作类似，所以不写出来了</p><h3 id="3-左平衡旋转代码"><a href="#3-左平衡旋转代码" class="headerlink" title="3.左平衡旋转代码"></a>3.左平衡旋转代码</h3><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> LH +1 </span><span class="token comment" spellcheck="true">/*  左高 */</span> <span class="token macro property">#<span class="token directive keyword">define</span> EH 0  </span><span class="token comment" spellcheck="true">/*  等高 */</span> <span class="token macro property">#<span class="token directive keyword">define</span> RH -1 </span><span class="token comment" spellcheck="true">/*  右高 */</span> <span class="token comment" spellcheck="true">/*  对以指针T所指结点为根的二叉树作左平衡旋转处理 */</span><span class="token comment" spellcheck="true">/*  本算法结束时，指针T指向新的根结点 */</span><span class="token keyword">void</span> <span class="token function">LeftBalance</span><span class="token punctuation">(</span>BiTree <span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token punctuation">{</span>     BiTree L<span class="token punctuation">,</span>Lr<span class="token punctuation">;</span>    L<span class="token operator">=</span><span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token operator">-></span>lchild<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/*  L指向T的左子树根结点 */</span>     <span class="token keyword">switch</span><span class="token punctuation">(</span>L<span class="token operator">-></span>bf<span class="token punctuation">)</span>    <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/*  检查T的左子树的平衡度，并作对应平衡处理 */</span>          <span class="token keyword">case</span> LH<span class="token punctuation">:</span> <span class="token comment" spellcheck="true">/*  新结点插入在T的左孩子的左子树上。要作单右旋处理 */</span>             <span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token operator">-></span>bf<span class="token operator">=</span>L<span class="token operator">-></span>bf<span class="token operator">=</span>EH<span class="token punctuation">;</span>            <span class="token function">R_Rotate</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>         <span class="token keyword">case</span> RH<span class="token punctuation">:</span> <span class="token comment" spellcheck="true">/*  新结点插入在T的左孩子的右子树上。要作双旋处理 */</span>             Lr<span class="token operator">=</span>L<span class="token operator">-></span>rchild<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/*  Lr指向T的左孩子的右子树根 */</span>             <span class="token keyword">switch</span><span class="token punctuation">(</span>Lr<span class="token operator">-></span>bf<span class="token punctuation">)</span>            <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/*  改动T及其左孩子的平衡因子 */</span>                 <span class="token keyword">case</span> LH<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token operator">-></span>bf<span class="token operator">=</span>RH<span class="token punctuation">;</span>                         L<span class="token operator">-></span>bf<span class="token operator">=</span>EH<span class="token punctuation">;</span>                         <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token keyword">case</span> EH<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token operator">-></span>bf<span class="token operator">=</span>L<span class="token operator">-></span>bf<span class="token operator">=</span>EH<span class="token punctuation">;</span>                         <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token keyword">case</span> RH<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token operator">-></span>bf<span class="token operator">=</span>EH<span class="token punctuation">;</span>                         L<span class="token operator">-></span>bf<span class="token operator">=</span>LH<span class="token punctuation">;</span>                         <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            Lr<span class="token operator">-></span>bf<span class="token operator">=</span>EH<span class="token punctuation">;</span>            <span class="token function">L_Rotate</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/*  对T的左子树作左旋平衡处理 */</span>             <span class="token function">R_Rotate</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/*  对T作右旋平衡处理 */</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="4-主函数代码"><a href="#4-主函数代码" class="headerlink" title="4.主函数代码"></a>4.主函数代码</h3><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/*  若在平衡的二叉排序树T中不存在和e有同样关键字的结点，则插入一个 */</span> <span class="token comment" spellcheck="true">/*  数据元素为e的新结点。并返回1，否则返回0。若因插入而使二叉排序树 */</span> <span class="token comment" spellcheck="true">/*  失去平衡，则作平衡旋转处理。布尔变量taller反映T长高与否。 */</span>Status <span class="token function">InsertAVL</span><span class="token punctuation">(</span>BiTree <span class="token operator">*</span>T<span class="token punctuation">,</span><span class="token keyword">int</span> e<span class="token punctuation">,</span>Status <span class="token operator">*</span>taller<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">*</span>T<span class="token punctuation">)</span>    <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/*  插入新结点。树“长高”，置taller为TRUE */</span>          <span class="token operator">*</span>T<span class="token operator">=</span><span class="token punctuation">(</span>BiTree<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BiTNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token operator">-></span>data<span class="token operator">=</span>e<span class="token punctuation">;</span> <span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token operator">-></span>lchild<span class="token operator">=</span><span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token operator">-></span>rchild<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token operator">-></span>bf<span class="token operator">=</span>EH<span class="token punctuation">;</span>         <span class="token operator">*</span>taller<span class="token operator">=</span>TRUE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token operator">==</span><span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token operator">-></span>data<span class="token punctuation">)</span>        <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/*  树中已存在和e有同样关键字的结点则不再插入 */</span>             <span class="token operator">*</span>taller<span class="token operator">=</span>FALSE<span class="token punctuation">;</span> <span class="token keyword">return</span> FALSE<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token operator">-></span>data<span class="token punctuation">)</span>        <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/*  应继续在T的左子树中进行搜索 */</span>             <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">InsertAVL</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token operator">-></span>lchild<span class="token punctuation">,</span>e<span class="token punctuation">,</span>taller<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">/*  未插入 */</span>                 <span class="token keyword">return</span> FALSE<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>taller<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">/*   已插入到T的左子树中且左子树“长高” */</span>                 <span class="token keyword">switch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token operator">-></span>bf<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">/*  检查T的平衡度 */</span>                 <span class="token punctuation">{</span>                    <span class="token keyword">case</span> LH<span class="token punctuation">:</span> <span class="token comment" spellcheck="true">/*  原本左子树比右子树高。须要作左平衡处理 */</span>                             <span class="token function">LeftBalance</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">*</span>taller<span class="token operator">=</span>FALSE<span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token keyword">case</span> EH<span class="token punctuation">:</span> <span class="token comment" spellcheck="true">/*  原本左、右子树等高，现因左子树增高而使树增高 */</span>                             <span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token operator">-></span>bf<span class="token operator">=</span>LH<span class="token punctuation">;</span> <span class="token operator">*</span>taller<span class="token operator">=</span>TRUE<span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token keyword">case</span> RH<span class="token punctuation">:</span> <span class="token comment" spellcheck="true">/*  原本右子树比左子树高，现左、右子树等高 */</span>                              <span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token operator">-></span>bf<span class="token operator">=</span>EH<span class="token punctuation">;</span> <span class="token operator">*</span>taller<span class="token operator">=</span>FALSE<span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/*  应继续在T的右子树中进行搜索 */</span>             <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">InsertAVL</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token operator">-></span>rchild<span class="token punctuation">,</span>e<span class="token punctuation">,</span>taller<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">/*  未插入 */</span>                 <span class="token keyword">return</span> FALSE<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">*</span>taller<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">/*  已插入到T的右子树且右子树“长高” */</span>                 <span class="token keyword">switch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token operator">-></span>bf<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">/*  检查T的平衡度 */</span>                 <span class="token punctuation">{</span>                    <span class="token keyword">case</span> LH<span class="token punctuation">:</span> <span class="token comment" spellcheck="true">/*  原本左子树比右子树高。现左、右子树等高 */</span>                             <span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token operator">-></span>bf<span class="token operator">=</span>EH<span class="token punctuation">;</span> <span class="token operator">*</span>taller<span class="token operator">=</span>FALSE<span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token keyword">case</span> EH<span class="token punctuation">:</span> <span class="token comment" spellcheck="true">/*  原本左、右子树等高，现因右子树增高而使树增高  */</span>                            <span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token operator">-></span>bf<span class="token operator">=</span>RH<span class="token punctuation">;</span> <span class="token operator">*</span>taller<span class="token operator">=</span>TRUE<span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token keyword">case</span> RH<span class="token punctuation">:</span> <span class="token comment" spellcheck="true">/*  原本右子树比左子树高，须要作右平衡处理 */</span>                             <span class="token function">RightBalance</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">*</span>taller<span class="token operator">=</span>FALSE<span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> TRUE<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 大话数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大话数据结构 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.6 二叉排序树</title>
      <link href="/2019/10/29/8.6-er-cha-pai-xu-shu/"/>
      <url>/2019/10/29/8.6-er-cha-pai-xu-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="8-6-二叉排序树"><a href="#8-6-二叉排序树" class="headerlink" title="8.6 二叉排序树"></a>8.6 二叉排序树</h1><blockquote><p>在前面我们了解了动态查找表（在查找的时候进行插入和删除的查找表），那什么结构可以实现动态查找表呢？</p></blockquote><h2 id="什么是二叉排序树？"><a href="#什么是二叉排序树？" class="headerlink" title="什么是二叉排序树？"></a>什么是二叉排序树？</h2><p>二叉排序树(Binary Sort Tree)，又称二叉查找树。它或者是一颗空树，或者是具有下列性质的二叉树。</p><ul><li>若它的左子树不空，则<strong>左子树</strong>上所有节点的值都<strong>小于它的根节点</strong>的值；</li><li>若它的右子树不空，则<strong>右子树</strong>上所有节点的值都<strong>大于它的根节点</strong>的值；</li><li>它的左、右子树也分别为二叉排序树。</li></ul><p>简而言之，就是左边孩子小，右边孩子大</p><h2 id="8-6-1-二叉排序树查找操作"><a href="#8-6-1-二叉排序树查找操作" class="headerlink" title="8.6.1 二叉排序树查找操作"></a>8.6.1 二叉排序树查找操作</h2><p>递归查找是否存在key；</p><h3 id="1-二叉树的结构"><a href="#1-二叉树的结构" class="headerlink" title="1.二叉树的结构"></a>1.二叉树的结构</h3><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 二叉树的二叉链表结点结构定义 */</span><span class="token keyword">typedef</span>  <span class="token keyword">struct</span> BiTNode <span class="token comment" spellcheck="true">/* 结点结构 */</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> data<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 结点数据 */</span>    <span class="token keyword">struct</span> BiTNode <span class="token operator">*</span>lchild<span class="token punctuation">,</span> <span class="token operator">*</span>rchild<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 左右孩子指针 */</span><span class="token punctuation">}</span> BiTNode<span class="token punctuation">,</span> <span class="token operator">*</span>BiTree<span class="token punctuation">;</span></code></pre><h3 id="2-代码："><a href="#2-代码：" class="headerlink" title="2.代码："></a>2.代码：</h3><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 递归查找二叉排序树T中是否存在key, */</span><span class="token comment" spellcheck="true">/* 指针f指向T的双亲，其初始调用值为NULL */</span><span class="token comment" spellcheck="true">/* 若查找成功，则指针p指向该数据元素结点，并返回TRUE */</span><span class="token comment" spellcheck="true">/* 否则指针p指向查找路径上访问的最后一个结点并返回FALSE */</span>Status <span class="token function">SearchBST</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">,</span> BiTree f<span class="token punctuation">,</span> BiTree <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>T<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">/*  查找不成功 */</span>    <span class="token comment" spellcheck="true">//判断是否是叶子</span>    <span class="token punctuation">{</span>         <span class="token operator">*</span>p <span class="token operator">=</span> f<span class="token punctuation">;</span>          <span class="token keyword">return</span> FALSE<span class="token punctuation">;</span>     <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token operator">==</span>T<span class="token operator">-></span>data<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">/*  查找成功 */</span>     <span class="token punctuation">{</span>         <span class="token operator">*</span>p <span class="token operator">=</span> T<span class="token punctuation">;</span>          <span class="token keyword">return</span> TRUE<span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token operator">&lt;</span>T<span class="token operator">-></span>data<span class="token punctuation">)</span>         <span class="token keyword">return</span> <span class="token function">SearchBST</span><span class="token punctuation">(</span>T<span class="token operator">-></span>lchild<span class="token punctuation">,</span> key<span class="token punctuation">,</span> T<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/*  在左子树中继续查找 */</span>    <span class="token keyword">else</span>          <span class="token keyword">return</span> <span class="token function">SearchBST</span><span class="token punctuation">(</span>T<span class="token operator">-></span>rchild<span class="token punctuation">,</span> key<span class="token punctuation">,</span> T<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/*  在右子树中继续查找 */</span><span class="token punctuation">}</span></code></pre><h2 id="8-6-2-插入操作"><a href="#8-6-2-插入操作" class="headerlink" title="8.6.2 插入操作"></a>8.6.2 插入操作</h2><h3 id="1-代码："><a href="#1-代码：" class="headerlink" title="1.代码："></a>1.代码：</h3><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/*  当二叉排序树T中不存在关键字等于key的数据元素时， */</span><span class="token comment" spellcheck="true">/*  插入key并返回TRUE，否则返回FALSE */</span>Status <span class="token function">InsertBST</span><span class="token punctuation">(</span>BiTree <span class="token operator">*</span>T<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>      BiTree p<span class="token punctuation">,</span>s<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">SearchBST</span><span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">/* 查找不成功，p是查到的最后一个结点 */</span>    <span class="token punctuation">{</span>        s <span class="token operator">=</span> <span class="token punctuation">(</span>BiTree<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BiTNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        s<span class="token operator">-></span>data <span class="token operator">=</span> key<span class="token punctuation">;</span>          s<span class="token operator">-></span>lchild <span class="token operator">=</span> s<span class="token operator">-></span>rchild <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token punctuation">)</span>             <span class="token operator">*</span>T <span class="token operator">=</span> s<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">/*  插入s为新的根结点 */</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token operator">&lt;</span>p<span class="token operator">-></span>data<span class="token punctuation">)</span>             p<span class="token operator">-></span>lchild <span class="token operator">=</span> s<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/*  插入s为左孩子 */</span>        <span class="token keyword">else</span>             p<span class="token operator">-></span>rchild <span class="token operator">=</span> s<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/*  插入s为右孩子 */</span>        <span class="token keyword">return</span> TRUE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">else</span>         <span class="token keyword">return</span> FALSE<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/*  树中已有关键字相同的结点，不再插入 */</span><span class="token punctuation">}</span></code></pre><h3 id><a href="#" class="headerlink" title></a></h3><h2 id="8-6-3-二叉排序树删除操作"><a href="#8-6-3-二叉排序树删除操作" class="headerlink" title="8.6.3 二叉排序树删除操作"></a>8.6.3 二叉排序树删除操作</h2><h3 id="1-叶子结点的删除"><a href="#1-叶子结点的删除" class="headerlink" title="1.叶子结点的删除"></a>1.叶子结点的删除</h3><p>直接删除，不影响原树；</p><p><img src="https://img-blog.csdn.net/20150609175928707" alt="è¿éåå°"></p><h3 id="2-只有左或右子树的节点的删除："><a href="#2-只有左或右子树的节点的删除：" class="headerlink" title="2.只有左或右子树的节点的删除："></a>2.只有左或右子树的节点的删除：</h3><p>节点删除后，将它的左子树或右子树整个移动到删除节点的位置即可，子承父业；</p><p><img src="https://img-blog.csdn.net/20150609180000500" alt="è¿éåå¾çæè¿°"></p><h3 id="3-既有左又有右子树的节点的删除："><a href="#3-既有左又有右子树的节点的删除：" class="headerlink" title="3.既有左又有右子树的节点的删除："></a>3.既有左又有右子树的节点的删除：</h3><p>找到需要删除的节点p的<strong>直接前驱</strong>或者直接后继<strong>s</strong>，用s来<strong>替换节点p</strong>，然后<strong>再删除节点s</strong>。</p><p><img src="https://img-blog.csdn.net/20150609180012387" alt="è¿éåå¾çæè¿°"></p><h3 id="4-代码："><a href="#4-代码：" class="headerlink" title="4.代码："></a>4.代码：</h3><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 若二叉排序树T中存在关键字等于key的数据元素时，则删除该数据元素结点, */</span><span class="token comment" spellcheck="true">/* 并返回TRUE；否则返回FALSE*/</span>Status <span class="token function">DeleteBST</span><span class="token punctuation">(</span>BiTree <span class="token operator">*</span>T<span class="token punctuation">,</span><span class="token keyword">int</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">*</span>T<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">/* 不存在关键字等于key的数据元素 */</span>         <span class="token keyword">return</span> FALSE<span class="token punctuation">;</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token operator">==</span><span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token operator">-></span>data<span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">/* 找到关键字等于key的数据元素 */</span> <span class="token comment" spellcheck="true">//找到要删除的地方</span>            <span class="token keyword">return</span> <span class="token function">Delete</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token operator">-></span>data<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token function">DeleteBST</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token operator">-></span>lchild<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token keyword">return</span> <span class="token function">DeleteBST</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token operator">-></span>rchild<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 从二叉排序树中删除结点p，并重接它的左或右子树。 */</span>Status <span class="token function">Delete</span><span class="token punctuation">(</span>BiTree <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>    BiTree q<span class="token punctuation">,</span>s<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>rchild<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">/* 右子树空则只需重接它的左子树（待删结点是叶子也走此分支) */</span>    <span class="token punctuation">{</span>        q<span class="token operator">=</span><span class="token operator">*</span>p<span class="token punctuation">;</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>lchild<span class="token punctuation">;</span> <span class="token function">free</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>lchild<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">/* 只需重接它的右子树 */</span>    <span class="token punctuation">{</span>        q<span class="token operator">=</span><span class="token operator">*</span>p<span class="token punctuation">;</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>rchild<span class="token punctuation">;</span> <span class="token function">free</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token comment" spellcheck="true">/* 左右子树均不空 */</span>    <span class="token punctuation">{</span>        q<span class="token operator">=</span><span class="token operator">*</span>p<span class="token punctuation">;</span> s<span class="token operator">=</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>lchild<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>s<span class="token operator">-></span>rchild<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">/* 转左，然后向右到尽头（找待删结点的前驱） */</span>        <span class="token punctuation">{</span>            q<span class="token operator">=</span>s<span class="token punctuation">;</span>            s<span class="token operator">=</span>s<span class="token operator">-></span>rchild<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>data<span class="token operator">=</span>s<span class="token operator">-></span>data<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/*  s指向被删结点的直接前驱（将被删结点前驱的值取代被删结点的值） */</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>q<span class="token operator">!=</span><span class="token operator">*</span>p<span class="token punctuation">)</span>            q<span class="token operator">-></span>rchild<span class="token operator">=</span>s<span class="token operator">-></span>lchild<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/*  重接q的右子树 */</span>         <span class="token keyword">else</span>            q<span class="token operator">-></span>lchild<span class="token operator">=</span>s<span class="token operator">-></span>lchild<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/*  重接q的左子树 */</span>        <span class="token function">free</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> TRUE<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="8-6-4-总结"><a href="#8-6-4-总结" class="headerlink" title="8.6.4 总结"></a>8.6.4 总结</h2><h3 id="1-时间复杂度是多少？"><a href="#1-时间复杂度是多少？" class="headerlink" title="1.时间复杂度是多少？"></a>1.时间复杂度是多少？</h3><p>当二叉排序树是比较平衡的时候，时间复杂度是O（logn），类似于折半查找，当不够平衡的时候，时间复杂度是O（n）</p>]]></content>
      
      
      <categories>
          
          <category> 大话数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大话数据结构 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.7 堆排序</title>
      <link href="/2019/10/29/9.7-dui-pai-xu/"/>
      <url>/2019/10/29/9.7-dui-pai-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="9-7-堆排序"><a href="#9-7-堆排序" class="headerlink" title="9.7 堆排序"></a>9.7 堆排序</h1><blockquote><p>我们前面学过简单选择排序，那么这里的堆排序和简单选择排序有什么关系呢？</p></blockquote><h2 id="堆是什么？"><a href="#堆是什么？" class="headerlink" title="堆是什么？"></a>堆是什么？</h2><p>堆是具有下列性质的<strong>完全二叉树</strong>：每个<strong>结点</strong>的值都<strong>大于或等于其左右孩子</strong>结点的值，称为<strong>大顶堆</strong>（例如图9-7-2左图）；或者每个结点的值都<strong>小于或等于其左右孩子</strong>结点的值，称为<strong>小顶堆</strong>（例如图9-7-2右图）</p><p><img src="https://images.cnblogs.com/cnblogs_com/cj723/dasu/9-7-02.jpg" alt="img"></p><h2 id="简单选择排序的缺点是什么？"><a href="#简单选择排序的缺点是什么？" class="headerlink" title="简单选择排序的缺点是什么？"></a>简单选择排序的缺点是什么？</h2><p>简单选择排序没有将每一趟比较结果保存下来，以至于在后面的比较中有与前面的重复的比较的现象。</p><h2 id="9-7-1-堆排序算法"><a href="#9-7-1-堆排序算法" class="headerlink" title="9.7.1 堆排序算法"></a>9.7.1 堆排序算法</h2><h3 id="1-堆排序是什么"><a href="#1-堆排序是什么" class="headerlink" title="1.堆排序是什么"></a>1.堆排序是什么</h3><p>堆排序（Heap Sort）就是利用堆（假设利用<strong>大顶堆</strong>）进行<strong>排序</strong>的方法</p><p>核心思想是：先将待排序的序列构造成一个<strong>大顶堆</strong>，然后将<strong>根节点移走</strong>，接着将<strong>剩余的n-1个序列</strong>重新构造成<strong>大顶堆</strong>，如此<strong>反复执行</strong>，便能得到一个有序序列了。</p><p><img src="https://images.cnblogs.com/cnblogs_com/cj723/dasu/9-7-04.jpg" alt="img"></p><h3 id="2-堆排序的代码："><a href="#2-堆排序的代码：" class="headerlink" title="2.堆排序的代码："></a>2.堆排序的代码：</h3><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 对顺序表L进行堆排序 */</span><span class="token keyword">void</span> <span class="token function">HeapSort</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">int</span> i<span class="token punctuation">;</span> <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>L<span class="token operator">-></span>length<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">/* 把L中的r构建成一个大顶堆 */</span>   <span class="token function">HeapAdjust</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span>i<span class="token punctuation">,</span>L<span class="token operator">-></span>length<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>L<span class="token operator">-></span>length<span class="token punctuation">;</span>i<span class="token operator">></span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">swap</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*将堆顶记录和当前未经排序子序列的最后一个记录交换*/</span>   <span class="token function">HeapAdjust</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>i<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/* 将L->r[1..i-1]重新调整为大顶堆 */</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在构建大顶堆的时候，为什么是<strong>i=L-&gt;length/2？</strong></p><p>因为<strong>i</strong>这时候是<strong>有孩子</strong>的结点</p><h3 id="3-HeapAdjust（堆调整）的代码是怎样的？"><a href="#3-HeapAdjust（堆调整）的代码是怎样的？" class="headerlink" title="3.HeapAdjust（堆调整）的代码是怎样的？"></a>3.HeapAdjust（堆调整）的代码是怎样的？</h3><pre class=" language-C"><code class="language-C">/* 已知L->r[s..m]中记录的关键字除L->r[s]之外均满足堆的定义， *//* 本函数调整L->r[s]的关键字,使L->r[s..m]成为一个大顶堆 */  //这里s是当前结点序号，m是长度void HeapAdjust(SqList *L,int s,int m){  int temp,j; temp=L->r[s]; for(j=2*s;j<=m;j*=2)  /* 沿关键字较大的孩子结点向下筛选 */ {  if(j<m && L->r[j]<L->r[j+1])   ++j;   /* j为关键字中较大的记录的下标 */  if(temp>=L->r[j])   break;   /* rc应插入在位置s上 */  L->r[s]=L->r[j];  s=j; } L->r[s]=temp;   /* 插入 */}</code></pre><p><img src="https://images.cnblogs.com/cnblogs_com/cj723/dasu/9-7-07.jpg" alt="img"></p><p><img src="https://images.cnblogs.com/cnblogs_com/cj723/dasu/9-7-08.jpg" alt="img"></p><p><img src="https://images.cnblogs.com/cnblogs_com/cj723/dasu/9-7-09.jpg" alt="img"></p><h3 id="4-堆调整后，怎么办？"><a href="#4-堆调整后，怎么办？" class="headerlink" title="4.堆调整后，怎么办？"></a>4.堆调整后，怎么办？</h3><pre class=" language-c"><code class="language-c"> <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>L<span class="token operator">-></span>length<span class="token punctuation">;</span>i<span class="token operator">></span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">swap</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 将堆顶记录和当前未经排序子序列的最后一个记录交换 */</span>   <span class="token function">HeapAdjust</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>i<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 将L->r[1..i-1]重新调整为大顶堆 */</span> <span class="token punctuation">}</span></code></pre><p><img src="https://images.cnblogs.com/cnblogs_com/cj723/dasu/9-7-10.jpg" alt="img"></p><p><img src="https://images.cnblogs.com/cnblogs_com/cj723/dasu/9-7-11.jpg" alt="img"></p><p><img src="https://images.cnblogs.com/cnblogs_com/cj723/dasu/9-7-12.jpg" alt="img"></p><p>堆排序的<strong>核心思想</strong>就是：<strong>从下往上找大的，大的放在前面</strong></p><h2 id="9-7-2-堆排序复杂度分析"><a href="#9-7-2-堆排序复杂度分析" class="headerlink" title="9.7.2 堆排序复杂度分析"></a>9.7.2 堆排序复杂度分析</h2><p>时间复杂度为O（nlogn）</p><p>不稳定的，不适合个数较少的情况</p>]]></content>
      
      
      <categories>
          
          <category> 大话数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大话数据结构 </tag>
            
            <tag> 排序 </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/10/26/jin-jie-zhi-guang-1.1-an-zhuo-5.0-xin-te-xing/"/>
      <url>/2019/10/26/jin-jie-zhi-guang-1.1-an-zhuo-5.0-xin-te-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="1-1-安卓5-0新特性"><a href="#1-1-安卓5-0新特性" class="headerlink" title="1.1 安卓5.0新特性"></a>1.1 安卓5.0新特性</h1><h2 id="1-1-1-Android-5-0-主要新特性"><a href="#1-1-1-Android-5-0-主要新特性" class="headerlink" title="1.1.1 Android 5.0 主要新特性"></a>1.1.1 Android 5.0 主要新特性</h2><p><strong>1. 全新的 Material Design 新风格</strong></p><p><strong>2. 支持多种设备</strong></p><p><strong>3. 全新的通知中心设计</strong></p><p><strong>4. 支持 64 位 ART 虚拟机（ART:Android runtime）</strong></p><p><strong>5. Overview</strong>（多任务，就是关后台程序的那个，小米手机上拉）</p><p><strong>6. 设备识别解锁</strong></p><p><strong>7. Ok Google 语音指令</strong>（语音助手）</p><p><strong>8. Face unlock 面部解锁</strong></p><h2 id="1-1-2-替换-ListView-和-GridView-的-RecyclerView"><a href="#1-1-2-替换-ListView-和-GridView-的-RecyclerView" class="headerlink" title="1.1.2 替换 ListView 和 GridView 的 RecyclerView"></a>1.1.2 替换 ListView 和 GridView 的 RecyclerView</h2><blockquote><p>有什么优点？</p><p>具有高度的解耦、异常的灵活性和更高的效率，通过设置它提供的不同 LayoutManager、ItemDecoration、ItemAnimator 可实现更加丰富多样的效果</p><p>缺点：</p><p>分割线需要自定义，另外列表的点击事件需要自己去实现。</p></blockquote><h3 id="1-设置分割线"><a href="#1-设置分割线" class="headerlink" title="1.设置分割线"></a>1.设置分割线</h3><p>现在谷歌有提供默认的分割线</p><pre class=" language-java"><code class="language-java">  recyclerView<span class="token punctuation">.</span><span class="token function">addItemDecoration</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">DividerItemDecoration</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>DividerItemDecoration<span class="token punctuation">.</span>VERTICAL<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>如果是网格布局的话，横着，竖着都画</p><h3 id="2-自定义分割线"><a href="#2-自定义分割线" class="headerlink" title="2.自定义分割线"></a>2.自定义分割线</h3><p>利用setDrawable方法</p><p>首先编写1个样式</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>shape</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>shape</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>rectangle<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    &lt;gradient        android:centerColor="#ff00ff00" //绿色        android:endColor="#ff0000ff"    //蓝色        android:startColor="#ffff0000"  //红色        android:type="linear" />    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>size</span> <span class="token attr-name"><span class="token namespace">android:</span>height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>3dp<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>shape</span><span class="token punctuation">></span></span></code></pre><p>然后</p><pre class=" language-java"><code class="language-java">        <span class="token comment" spellcheck="true">//添加自定义分割线</span>        DividerItemDecoration divider <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DividerItemDecoration</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>DividerItemDecoration<span class="token punctuation">.</span>VERTICAL<span class="token punctuation">)</span><span class="token punctuation">;</span>        divider<span class="token punctuation">.</span><span class="token function">setDrawable</span><span class="token punctuation">(</span>ContextCompat<span class="token punctuation">.</span><span class="token function">getDrawable</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>R<span class="token punctuation">.</span>drawable<span class="token punctuation">.</span>custom_divider<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        recyclerView<span class="token punctuation">.</span><span class="token function">addItemDecoration</span><span class="token punctuation">(</span>divider<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>或者用代码</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Created by Moon on 2015/11/21. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DividerItemDecoration</span> <span class="token keyword">extends</span> <span class="token class-name">RecyclerView<span class="token punctuation">.</span>ItemDecoration</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ATTRS <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>            android<span class="token punctuation">.</span>R<span class="token punctuation">.</span>attr<span class="token punctuation">.</span>listDivider    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> HORIZONTAL_LIST <span class="token operator">=</span> LinearLayoutManager<span class="token punctuation">.</span>HORIZONTAL<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> VERTICAL_LIST <span class="token operator">=</span> LinearLayoutManager<span class="token punctuation">.</span>VERTICAL<span class="token punctuation">;</span>    <span class="token keyword">private</span> Drawable mDivider<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> mOrientation<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">DividerItemDecoration</span><span class="token punctuation">(</span>Context context<span class="token punctuation">,</span> <span class="token keyword">int</span> orientation<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> TypedArray a <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">obtainStyledAttributes</span><span class="token punctuation">(</span>ATTRS<span class="token punctuation">)</span><span class="token punctuation">;</span>        mDivider <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">getDrawable</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        a<span class="token punctuation">.</span><span class="token function">recycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setOrientation</span><span class="token punctuation">(</span>orientation<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setOrientation</span><span class="token punctuation">(</span><span class="token keyword">int</span> orientation<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>orientation <span class="token operator">!=</span> HORIZONTAL_LIST <span class="token operator">&amp;&amp;</span> orientation <span class="token operator">!=</span> VERTICAL_LIST<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"invalid orientation"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        mOrientation <span class="token operator">=</span> orientation<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onDraw</span><span class="token punctuation">(</span>Canvas c<span class="token punctuation">,</span> RecyclerView parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mOrientation <span class="token operator">==</span> VERTICAL_LIST<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">drawVertical</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token function">drawHorizontal</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">drawVertical</span><span class="token punctuation">(</span>Canvas c<span class="token punctuation">,</span> RecyclerView parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> left <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">getPaddingLeft</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> right <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">getWidth</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> parent<span class="token punctuation">.</span><span class="token function">getPaddingRight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> childCount <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">getChildCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> childCount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> View child <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">getChildAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            android<span class="token punctuation">.</span>support<span class="token punctuation">.</span>v7<span class="token punctuation">.</span>widget<span class="token punctuation">.</span>RecyclerView v <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">android<span class="token punctuation">.</span>support<span class="token punctuation">.</span>v7<span class="token punctuation">.</span>widget<span class="token punctuation">.</span>RecyclerView</span><span class="token punctuation">(</span>parent<span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">final</span> RecyclerView<span class="token punctuation">.</span>LayoutParams params <span class="token operator">=</span> <span class="token punctuation">(</span>RecyclerView<span class="token punctuation">.</span>LayoutParams<span class="token punctuation">)</span> child                    <span class="token punctuation">.</span><span class="token function">getLayoutParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">final</span> <span class="token keyword">int</span> top <span class="token operator">=</span> child<span class="token punctuation">.</span><span class="token function">getBottom</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> params<span class="token punctuation">.</span>bottomMargin<span class="token punctuation">;</span>            <span class="token keyword">final</span> <span class="token keyword">int</span> bottom <span class="token operator">=</span> top <span class="token operator">+</span> mDivider<span class="token punctuation">.</span><span class="token function">getIntrinsicHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            mDivider<span class="token punctuation">.</span><span class="token function">setBounds</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> top<span class="token punctuation">,</span> right<span class="token punctuation">,</span> bottom<span class="token punctuation">)</span><span class="token punctuation">;</span>            mDivider<span class="token punctuation">.</span><span class="token function">draw</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">drawHorizontal</span><span class="token punctuation">(</span>Canvas c<span class="token punctuation">,</span> RecyclerView parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> top <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">getPaddingTop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> bottom <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">getHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> parent<span class="token punctuation">.</span><span class="token function">getPaddingBottom</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> childCount <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">getChildCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> childCount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> View child <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">getChildAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">final</span> RecyclerView<span class="token punctuation">.</span>LayoutParams params <span class="token operator">=</span> <span class="token punctuation">(</span>RecyclerView<span class="token punctuation">.</span>LayoutParams<span class="token punctuation">)</span> child                    <span class="token punctuation">.</span><span class="token function">getLayoutParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">final</span> <span class="token keyword">int</span> left <span class="token operator">=</span> child<span class="token punctuation">.</span><span class="token function">getRight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> params<span class="token punctuation">.</span>rightMargin<span class="token punctuation">;</span>            <span class="token keyword">final</span> <span class="token keyword">int</span> right <span class="token operator">=</span> left <span class="token operator">+</span> mDivider<span class="token punctuation">.</span><span class="token function">getIntrinsicHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            mDivider<span class="token punctuation">.</span><span class="token function">setBounds</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> top<span class="token punctuation">,</span> right<span class="token punctuation">,</span> bottom<span class="token punctuation">)</span><span class="token punctuation">;</span>            mDivider<span class="token punctuation">.</span><span class="token function">draw</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getItemOffsets</span><span class="token punctuation">(</span>Rect outRect<span class="token punctuation">,</span> <span class="token keyword">int</span> itemPosition<span class="token punctuation">,</span> RecyclerView parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mOrientation <span class="token operator">==</span> VERTICAL_LIST<span class="token punctuation">)</span> <span class="token punctuation">{</span>            outRect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> mDivider<span class="token punctuation">.</span><span class="token function">getIntrinsicHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            outRect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> mDivider<span class="token punctuation">.</span><span class="token function">getIntrinsicWidth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="3-自定义点击事件"><a href="#3-自定义点击事件" class="headerlink" title="3.自定义点击事件"></a>3.自定义点击事件</h3><ol><li>定义接口</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">OnItemClickListener</span>    <span class="token punctuation">{</span>        <span class="token keyword">void</span> <span class="token function">onItemClick</span><span class="token punctuation">(</span>View view<span class="token punctuation">,</span> <span class="token keyword">int</span> position<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">void</span> <span class="token function">onItemLongClick</span><span class="token punctuation">(</span>View view<span class="token punctuation">,</span><span class="token keyword">int</span> position<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>2.这里写的为了调用方法，用到上面的接口回调</p><pre class=" language-java"><code class="language-java">   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setOnItemClickListener</span><span class="token punctuation">(</span>OnItemClickListener mOnItemClickListener<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>mOnItemClickListener <span class="token operator">=</span> mOnItemClickListener<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>3.在onCreateViewHolder里面设置</p><pre class=" language-java"><code class="language-java"> view<span class="token punctuation">.</span><span class="token function">setOnClickListener</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        view<span class="token punctuation">.</span><span class="token function">setOnLongClickListener</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//点击事件</span>        <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onClick</span><span class="token punctuation">(</span>View view<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mOnItemClickListener <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//回调</span>            mOnItemClickListener<span class="token punctuation">.</span><span class="token function">onItemClick</span><span class="token punctuation">(</span>view<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>view<span class="token punctuation">.</span><span class="token function">getTag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//长按事件</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">onLongClick</span><span class="token punctuation">(</span>View view<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mOnItemClickListener <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//回调</span>            mOnItemClickListener<span class="token punctuation">.</span><span class="token function">onItemLongClick</span><span class="token punctuation">(</span>view<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>view<span class="token punctuation">.</span><span class="token function">getTag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>4.在activity中</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">setLister</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        mHomeAdaper<span class="token punctuation">.</span><span class="token function">setOnItemClickListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HomeAdapter<span class="token punctuation">.</span>OnItemClickListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onItemClick</span><span class="token punctuation">(</span>View view<span class="token punctuation">,</span> <span class="token keyword">int</span> position<span class="token punctuation">)</span> <span class="token punctuation">{</span>                Toast<span class="token punctuation">.</span><span class="token function">makeText</span><span class="token punctuation">(</span>RecyclerViewActivity<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">"点击第"</span> <span class="token operator">+</span> <span class="token punctuation">(</span>position <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"条"</span><span class="token punctuation">,</span> Toast<span class="token punctuation">.</span>LENGTH_SHORT<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onItemLongClick</span><span class="token punctuation">(</span>View view<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token keyword">int</span> position<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">new</span> <span class="token class-name">AlertDialog<span class="token punctuation">.</span>Builder</span><span class="token punctuation">(</span>RecyclerViewActivity<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">)</span>                        <span class="token punctuation">.</span><span class="token function">setTitle</span><span class="token punctuation">(</span><span class="token string">"确认删除吗？"</span><span class="token punctuation">)</span>                        <span class="token punctuation">.</span><span class="token function">setNegativeButton</span><span class="token punctuation">(</span><span class="token string">"取消"</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span>                        <span class="token punctuation">.</span><span class="token function">setPositiveButton</span><span class="token punctuation">(</span><span class="token string">"确定"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">DialogInterface<span class="token punctuation">.</span>OnClickListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token annotation punctuation">@Override</span>                            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onClick</span><span class="token punctuation">(</span>DialogInterface dialogInterface<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                                mHomeAdaper<span class="token punctuation">.</span><span class="token function">removeData</span><span class="token punctuation">(</span>position<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                        <span class="token punctuation">}</span><span class="token punctuation">)</span>                        <span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>5.总的代码Adapter</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>liuwangshu<span class="token punctuation">.</span>myrecyclerview<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>content<span class="token punctuation">.</span>Context<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>support<span class="token punctuation">.</span>v7<span class="token punctuation">.</span>widget<span class="token punctuation">.</span>RecyclerView<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Log<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>view<span class="token punctuation">.</span>LayoutInflater<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>view<span class="token punctuation">.</span>View<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>view<span class="token punctuation">.</span>ViewGroup<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>widget<span class="token punctuation">.</span>FrameLayout<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>widget<span class="token punctuation">.</span>TextView<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>view<span class="token punctuation">.</span>ViewGroup<span class="token punctuation">.</span>LayoutParams<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Created by Moon on 2015/11/21. */</span><span class="token keyword">class</span> <span class="token class-name">HomeAdapter</span> <span class="token keyword">extends</span> <span class="token class-name">RecyclerView<span class="token punctuation">.</span>Adapter</span><span class="token operator">&lt;</span>HomeAdapter<span class="token punctuation">.</span>MyViewHolder<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">View<span class="token punctuation">.</span>OnClickListener</span><span class="token punctuation">,</span>View<span class="token punctuation">.</span>OnLongClickListener<span class="token punctuation">{</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> mList<span class="token punctuation">;</span>    <span class="token keyword">private</span> Context mContext<span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> OnItemClickListener mOnItemClickListener<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">HomeAdapter</span><span class="token punctuation">(</span>Context mContext<span class="token punctuation">,</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span>mList<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>mContext<span class="token operator">=</span>mContext<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>mList<span class="token operator">=</span>mList<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">OnItemClickListener</span>    <span class="token punctuation">{</span>        <span class="token keyword">void</span> <span class="token function">onItemClick</span><span class="token punctuation">(</span>View view<span class="token punctuation">,</span> <span class="token keyword">int</span> position<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">void</span> <span class="token function">onItemLongClick</span><span class="token punctuation">(</span>View view<span class="token punctuation">,</span><span class="token keyword">int</span> position<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setOnItemClickListener</span><span class="token punctuation">(</span>OnItemClickListener mOnItemClickListener<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>mOnItemClickListener <span class="token operator">=</span> mOnItemClickListener<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">removeData</span><span class="token punctuation">(</span><span class="token keyword">int</span> position<span class="token punctuation">)</span> <span class="token punctuation">{</span>        mList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>position<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">notifyItemRemoved</span><span class="token punctuation">(</span>position<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//动态效果</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> MyViewHolder <span class="token function">onCreateViewHolder</span><span class="token punctuation">(</span>ViewGroup parent<span class="token punctuation">,</span> <span class="token keyword">int</span> viewType<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        View view<span class="token operator">=</span>LayoutInflater<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>                mContext<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">inflate</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>layout<span class="token punctuation">.</span>item_recycler<span class="token punctuation">,</span> parent<span class="token punctuation">,</span>                <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        MyViewHolder holder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyViewHolder</span><span class="token punctuation">(</span>view<span class="token punctuation">)</span><span class="token punctuation">;</span>        view<span class="token punctuation">.</span><span class="token function">setOnClickListener</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        view<span class="token punctuation">.</span><span class="token function">setOnLongClickListener</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> holder<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onBindViewHolder</span><span class="token punctuation">(</span><span class="token keyword">final</span> MyViewHolder holder<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token keyword">int</span> position<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        holder<span class="token punctuation">.</span>itemView<span class="token punctuation">.</span><span class="token function">setTag</span><span class="token punctuation">(</span>position<span class="token punctuation">)</span><span class="token punctuation">;</span>        holder<span class="token punctuation">.</span>tv<span class="token punctuation">.</span><span class="token function">setText</span><span class="token punctuation">(</span>mList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>position<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onClick</span><span class="token punctuation">(</span>View view<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mOnItemClickListener <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            mOnItemClickListener<span class="token punctuation">.</span><span class="token function">onItemClick</span><span class="token punctuation">(</span>view<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>view<span class="token punctuation">.</span><span class="token function">getTag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">onLongClick</span><span class="token punctuation">(</span>View view<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mOnItemClickListener <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            mOnItemClickListener<span class="token punctuation">.</span><span class="token function">onItemLongClick</span><span class="token punctuation">(</span>view<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>view<span class="token punctuation">.</span><span class="token function">getTag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getItemCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> mList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">class</span> <span class="token class-name">MyViewHolder</span> <span class="token keyword">extends</span> <span class="token class-name">RecyclerView<span class="token punctuation">.</span>ViewHolder</span>    <span class="token punctuation">{</span>        TextView tv<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">MyViewHolder</span><span class="token punctuation">(</span>View view<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">super</span><span class="token punctuation">(</span>view<span class="token punctuation">)</span><span class="token punctuation">;</span>            tv <span class="token operator">=</span> <span class="token punctuation">(</span>TextView<span class="token punctuation">)</span> view<span class="token punctuation">.</span><span class="token function">findViewById</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>tv_item<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="1-1-4-3种通知"><a href="#1-1-4-3种通知" class="headerlink" title="1.1.4 3种通知"></a>1.1.4 3种通知</h2><h3 id="1-普通通知"><a href="#1-普通通知" class="headerlink" title="1.普通通知"></a>1.普通通知</h3><p><img src="https://i.loli.net/2019/10/10/qyiDrenEUch7A1t.jpg" alt></p><p>就是显示在那个状态栏的通知</p><h3 id="2-折叠式"><a href="#2-折叠式" class="headerlink" title="2.折叠式"></a>2.折叠式</h3><p>它有两种状态，一种是普通状态下的视图（如果不是自定义的话和上面普通通知的视图样式一样），一种是展开状态下的视图。</p><p> 自定义的视图，而这个视图显示的进程和我们创建视图的进程不再一个进程，所以我们需要使用RemoteViews，首先要使用RemoteViews来创建我们的自定义视图:</p><pre class=" language-java"><code class="language-java"> <span class="token comment" spellcheck="true">//用RemoteViews来创建自定义Notification视图</span>RemoteViews remoteViews <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RemoteViews</span><span class="token punctuation">(</span><span class="token function">getPackageName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> R<span class="token punctuation">.</span>layout<span class="token punctuation">.</span>view_fold<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>1.展开后的视图的布局文件</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>LinearLayout</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100dp<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>background</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@drawable/fold<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>orientation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>horizontal<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ImageView</span>    <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/iv_image<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100dp<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100dp<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@drawable/fold<span class="token punctuation">"</span></span>    <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextView</span>        <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/tv_text<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_marginTop</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>30dp<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_marginLeft</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>150dp<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>展开后的自定义视图<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>textColor</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@color/colorPrimaryDark<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>LinearLayout</span><span class="token punctuation">></span></span></code></pre><p>2.指定展开的视图</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//指定展开时的视图</span>notification<span class="token punctuation">.</span>bigContentView <span class="token operator">=</span> remoteViews<span class="token punctuation">;</span></code></pre><p>3.总的代码</p><pre class=" language-java"><code class="language-java">        Notification<span class="token punctuation">.</span>Builder builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Notification<span class="token punctuation">.</span>Builder</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Intent mIntent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Intent</span><span class="token punctuation">(</span>Intent<span class="token punctuation">.</span>ACTION_VIEW<span class="token punctuation">,</span> Uri<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">"http://blog.csdn.net/itachi85/"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        PendingIntent pendingIntent <span class="token operator">=</span> PendingIntent<span class="token punctuation">.</span><span class="token function">getActivity</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> mIntent<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        builder<span class="token punctuation">.</span><span class="token function">setContentIntent</span><span class="token punctuation">(</span>pendingIntent<span class="token punctuation">)</span><span class="token punctuation">;</span>        builder<span class="token punctuation">.</span><span class="token function">setSmallIcon</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>drawable<span class="token punctuation">.</span>foldleft<span class="token punctuation">)</span><span class="token punctuation">;</span>        builder<span class="token punctuation">.</span><span class="token function">setLargeIcon</span><span class="token punctuation">(</span>BitmapFactory<span class="token punctuation">.</span><span class="token function">decodeResource</span><span class="token punctuation">(</span><span class="token function">getResources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> R<span class="token punctuation">.</span>drawable<span class="token punctuation">.</span>lanucher<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        builder<span class="token punctuation">.</span><span class="token function">setAutoCancel</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        builder<span class="token punctuation">.</span><span class="token function">setContentTitle</span><span class="token punctuation">(</span><span class="token string">"折叠式通知"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//用RemoteViews来创建自定义Notification视图</span>        RemoteViews remoteViews <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RemoteViews</span><span class="token punctuation">(</span><span class="token function">getPackageName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> R<span class="token punctuation">.</span>layout<span class="token punctuation">.</span>view_fold<span class="token punctuation">)</span><span class="token punctuation">;</span>        Notification notification <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//指定展开时的视图</span>        notification<span class="token punctuation">.</span>bigContentView <span class="token operator">=</span> remoteViews<span class="token punctuation">;</span>        notificationManager<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> notification<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>4.界面展示</p><p><img src="https://i.loli.net/2019/10/10/MH24lmvzAUGiafL.jpg" alt></p><p><img src="https://i.loli.net/2019/10/10/dkVYmfyvABLgjKr.jpg" alt></p><h3 id="3-悬挂式"><a href="#3-悬挂式" class="headerlink" title="3.悬挂式"></a>3.悬挂式</h3><p>就是不需要下拉状态栏就行了</p><p><img src="https://i.loli.net/2019/10/10/VKYW8LRlDdj3ytb.jpg" alt></p><p>1.不同的是，需要用</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//如果描述的PendingIntent已经存在，则在产生新的Intent之前会先取消掉当前的</span>        PendingIntent hangPendingIntent <span class="token operator">=</span> PendingIntent<span class="token punctuation">.</span><span class="token function">getActivity</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> hangIntent<span class="token punctuation">,</span> PendingIntent<span class="token punctuation">.</span>FLAG_CANCEL_CURRENT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这里需要设置setFullScreenIntent而不是setContentIntent</span>        builder<span class="token punctuation">.</span><span class="token function">setFullScreenIntent</span><span class="token punctuation">(</span>hangPendingIntent<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="1-1-5-ToolBar和Palette"><a href="#1-1-5-ToolBar和Palette" class="headerlink" title="1.1.5 ToolBar和Palette"></a>1.1.5 ToolBar和Palette</h2><h3 id="1-怎么在ToolBar中的按钮中指定控件呢"><a href="#1-怎么在ToolBar中的按钮中指定控件呢" class="headerlink" title="1.怎么在ToolBar中的按钮中指定控件呢"></a>1.怎么在ToolBar中的按钮中指定控件呢</h3><p>其实就是在menu中的item里面</p><p>app:actionViewClass=”控件”就行了</p><h2 id="2-Palette的应用"><a href="#2-Palette的应用" class="headerlink" title="2.Palette的应用"></a>2.Palette的应用</h2><blockquote><p>这个是什么，其实就是得到图片的色调的</p></blockquote><p>怎么使用？</p><p>1.导入包</p><pre><code>‘com.android.support:palette-v7:23.0.1</code></pre><p>2.先获取图片的Bitmap</p><pre class=" language-java"><code class="language-java">        Bitmap bitmap<span class="token operator">=</span> BitmapFactory<span class="token punctuation">.</span><span class="token function">decodeResource</span><span class="token punctuation">(</span><span class="token function">getResources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>R<span class="token punctuation">.</span>drawable<span class="token punctuation">.</span>bitmap<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>3.然后在Palette的回调中获取色调</p><pre class=" language-java"><code class="language-java"> Palette<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>bitmap<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">generate</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Palette<span class="token punctuation">.</span>PaletteAsyncListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onGenerated</span><span class="token punctuation">(</span>Palette palette<span class="token punctuation">)</span> <span class="token punctuation">{</span>                Palette<span class="token punctuation">.</span>Swatch swatch<span class="token operator">=</span>palette<span class="token punctuation">.</span><span class="token function">getVibrantSwatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//得到他的rgb色</span>                <span class="token function">getSupportActionBar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setBackgroundDrawable</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ColorDrawable</span><span class="token punctuation">(</span>swatch<span class="token punctuation">.</span><span class="token function">getRgb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>4.内置提取颜色的种类</p><ul><li>Vibrant 充满活力的</li><li>Vibrant dark充满活力的黑</li><li>Vibrant light 充满活力的亮</li><li>Muted 柔和</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>7.7 最短路径</title>
      <link href="/2019/10/26/7.7-zui-duan-lu-jing/"/>
      <url>/2019/10/26/7.7-zui-duan-lu-jing/</url>
      
        <content type="html"><![CDATA[<h1 id="7-7-最短路径"><a href="#7-7-最短路径" class="headerlink" title="7.7 最短路径"></a>7.7 最短路径</h1><blockquote><p>上节我们探讨了最小生成树的生成方法，分别是prim算法和Kruskal算法,这节课我们来探讨下求最短路径的算法</p><p>上上节我们探讨了广度优先和深度优先，其实这与本节有一定的关系</p></blockquote><h2 id="7-7-1-Dijkstra算法"><a href="#7-7-1-Dijkstra算法" class="headerlink" title="7.7.1 Dijkstra算法"></a>7.7.1 Dijkstra算法</h2><h3 id="1-什么是Dijkstra算法？"><a href="#1-什么是Dijkstra算法？" class="headerlink" title="1.什么是Dijkstra算法？"></a>1.什么是Dijkstra算法？</h3><p>用于计算一个结点到其他结点的最短路径</p><p>算法的<strong>主要特点</strong>是以起始点为中心向外层层扩展(<strong>广度优先搜索</strong>思想)， 直到扩展到终点为止，不断地找最小值的点中的连线</p><h3 id="2-图解"><a href="#2-图解" class="headerlink" title="2.图解"></a>2.图解</h3><p><img src="https://s2.ax1x.com/2019/10/26/KBYanO.png" alt="KBYanO.png"></p><p>其实就是不断找最短的距离，要和之前的比较</p><h3 id="3-算法"><a href="#3-算法" class="headerlink" title="3.算法"></a>3.算法</h3><p><code>final</code>数组为<strong>已求</strong>得<strong>最短路径</strong>的顶点<strong>集合</strong>，<code>D</code>数组为起点到各顶点的最短路径的<strong>权值和</strong>， <code>P</code>数组为最短路径的<strong>路径的顶点</strong></p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* Dijkstra算法， 求有向网 G 的 v0 顶点到其余顶点 v 最短路径 P[v] 及带权长度 D[v], P[v] 的值为前驱顶点下标, * D[v] 表示 v0 到 v 的最短路径长度和 */</span><span class="token keyword">void</span> <span class="token function">ShortestPath_Dijkstra</span><span class="token punctuation">(</span>MGraph G<span class="token punctuation">,</span> <span class="token keyword">int</span> v0<span class="token punctuation">,</span> ShortPathTable <span class="token operator">*</span>D<span class="token punctuation">,</span> Patharc <span class="token operator">*</span>P<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> min<span class="token punctuation">,</span> k<span class="token punctuation">,</span> final<span class="token punctuation">[</span>MAXVEX<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* final[w] = 1 表示求得顶点 v0 至 vw 的最短路径 */</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> v <span class="token operator">&lt;</span> G<span class="token punctuation">.</span>numVertexes<span class="token punctuation">;</span> v<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">/* 初始化数据 */</span>    <span class="token punctuation">{</span>        final<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/* 全部顶点初始化为未知最短路径状态 */</span>        <span class="token punctuation">(</span><span class="token operator">*</span>D<span class="token punctuation">)</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> G<span class="token punctuation">.</span>arc<span class="token punctuation">[</span>v0<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 将与 v0 顶点有连线的顶点加上权值 */</span>        <span class="token punctuation">(</span><span class="token operator">*</span>P<span class="token punctuation">)</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/* 初始化路径数组 P 为 0 */</span>    <span class="token punctuation">}</span>    final<span class="token punctuation">[</span>v0<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* v0 至 v0 不需要求路径 */</span>    <span class="token punctuation">(</span><span class="token operator">*</span>D<span class="token punctuation">)</span><span class="token punctuation">[</span>v0<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* v0 至 v0 路径为 0 */</span>    <span class="token comment" spellcheck="true">/* 开始主循环, 每次求得 v0 到某个 v 顶点的最短路径 */</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> v <span class="token operator">&lt;</span> G<span class="token punctuation">.</span>numVertexes<span class="token punctuation">;</span> v<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        min <span class="token operator">=</span> INF<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 当前所知离 v0 顶点的最近距离 */</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> w <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> w <span class="token operator">&lt;</span> G<span class="token punctuation">.</span>numVertexes<span class="token punctuation">;</span> w<span class="token operator">++</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">/* 寻找离 v0 最近的顶点 */</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>final<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">*</span>D<span class="token punctuation">)</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">&lt;</span> min<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                min <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>D<span class="token punctuation">)</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* w 顶点离 v0 顶点更近 */</span>                k <span class="token operator">=</span> w<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        final<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 将目前找到的最近的顶点置为 1 */</span>        <span class="token comment" spellcheck="true">//这里是更新最短路径长度</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> w <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> w <span class="token operator">&lt;</span> G<span class="token punctuation">.</span>numVertexes<span class="token punctuation">;</span> w<span class="token operator">++</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">/* 更新当前最短路径及距离 */</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/* 如果经过 v 顶点的路径比现在这条路径的长度短的话 */</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>final<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>min <span class="token operator">+</span> G<span class="token punctuation">.</span>arc<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token operator">*</span>D<span class="token punctuation">)</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">/* 说明找到了更短的路径, 修改 D[w] 和 P[w] */</span>                <span class="token punctuation">(</span><span class="token operator">*</span>D<span class="token punctuation">)</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">=</span> min <span class="token operator">+</span> G<span class="token punctuation">.</span>arc<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 修改当前路径长度 */</span>                <span class="token punctuation">(</span><span class="token operator">*</span>P<span class="token punctuation">)</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">=</span> k<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="4-如果还想知道v3到v5这样任意顶点开始的最短路径怎么办？"><a href="#4-如果还想知道v3到v5这样任意顶点开始的最短路径怎么办？" class="headerlink" title="4.如果还想知道v3到v5这样任意顶点开始的最短路径怎么办？"></a>4.如果还想知道v3到v5这样任意顶点开始的最短路径怎么办？</h3><p>对每个顶点作为源点运行一次上述算法</p><p>时间复杂度是O(n3)</p><h2 id="7-7-2-Floyd算法"><a href="#7-7-2-Floyd算法" class="headerlink" title="7.7.2 Floyd算法"></a>7.7.2 Floyd算法</h2><h3 id="1-什么是Floyd算法"><a href="#1-什么是Floyd算法" class="headerlink" title="1.什么是Floyd算法"></a>1.什么是<code>Floyd</code>算法</h3><p>在给定的加权图中求最短路径的算法，其实就是不断尝试借助中间结点，而不是之间一步到位的结点，来求最短路径</p><h3 id="2-核心是什么？"><a href="#2-核心是什么？" class="headerlink" title="2.核心是什么？"></a>2.核心是什么？</h3><p><img src="https://s2.ax1x.com/2019/10/26/KBU3NQ.jpg" alt="KBU3NQ.jpg"></p><h3 id="3-步骤是什么？"><a href="#3-步骤是什么？" class="headerlink" title="3.步骤是什么？"></a>3.步骤是什么？</h3><ol><li>首先明确定义，定义两个二维数组<code>D[MAXVEX][MAXVEX]</code>和<code>P[MAXVEX][MAXVEX]</code>，<strong>D</strong>数组代表顶点到顶点的<strong>最短路径权值和</strong>矩阵， <code>P</code>代表对应顶点的<strong>最小路径前驱矩阵</strong>。</li><li>初始的时候，将矩阵<code>D</code>中顶点<code>D[v][w]</code>设置为顶点<code>v</code>到顶点<code>w</code>的<strong>权值</strong>，若两顶点<strong>不相连</strong>，则<code>D[v][w] = INF</code>。</li><li>接下来对矩阵<code>D</code>更新， <strong>如果D[v][w] &gt; D[v][k] + D[k][w]</strong><code>，</code>k<code>表示</code>v、w`两顶点通过中转顶点，该表达式表示通过中转顶点的权值和较小时，<strong>更新v、w权值和</strong>。</li></ol><p><img src="https://s2.ax1x.com/2019/10/26/KBa3qK.png" alt="KBa3qK.png"></p><h3 id="4-算法是什么？"><a href="#4-算法是什么？" class="headerlink" title="4.算法是什么？"></a>4.算法是什么？</h3><p>结构</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> MAXVEX 9</span><span class="token macro property">#<span class="token directive keyword">define</span> INF 65535</span><span class="token keyword">typedef</span> <span class="token keyword">int</span> Patharc<span class="token punctuation">[</span>MAXVEX<span class="token punctuation">]</span><span class="token punctuation">[</span>MAXVEX<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">int</span> ShortPathTable<span class="token punctuation">[</span>MAXVEX<span class="token punctuation">]</span><span class="token punctuation">[</span>MAXVEX<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> vexs<span class="token punctuation">[</span>MAXVEX<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> arc<span class="token punctuation">[</span>MAXVEX<span class="token punctuation">]</span><span class="token punctuation">[</span>MAXVEX<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> numVertexes<span class="token punctuation">,</span> numEdges<span class="token punctuation">;</span><span class="token punctuation">}</span>MGraph<span class="token punctuation">;</span></code></pre><p>算法：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* Floyd 算法， 求网图 G 中各顶点 v 到其余顶点 w 的最短路径 P[v][w] 及带权长度 D[v][w] */</span><span class="token keyword">void</span> <span class="token function">ShortestPath_Floyd</span><span class="token punctuation">(</span>MGraph G<span class="token punctuation">,</span> Patharc <span class="token operator">*</span>P<span class="token punctuation">,</span> ShortPathTable <span class="token operator">*</span>D<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 初始化 D 与 P */</span>    <span class="token comment" spellcheck="true">//双重循环初始化</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> v <span class="token operator">&lt;</span> G<span class="token punctuation">.</span>numVertexes<span class="token punctuation">;</span> <span class="token operator">++</span>v<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> w <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> w <span class="token operator">&lt;</span> G<span class="token punctuation">.</span>numVertexes<span class="token punctuation">;</span> <span class="token operator">++</span>w<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">(</span><span class="token operator">*</span>D<span class="token punctuation">)</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">=</span> G<span class="token punctuation">.</span>arc<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* D[v][w] 值即为对应顶点间的权值 */</span>            <span class="token punctuation">(</span><span class="token operator">*</span>P<span class="token punctuation">)</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">=</span> w<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 初始化 P */</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//三重循环更新最短路径</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> G<span class="token punctuation">.</span>numVertexes<span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//k是中间的结点</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> v <span class="token operator">&lt;</span> G<span class="token punctuation">.</span>numVertexes<span class="token punctuation">;</span> <span class="token operator">++</span>v<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> w <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> w <span class="token operator">&lt;</span> G<span class="token punctuation">.</span>numVertexes<span class="token punctuation">;</span> <span class="token operator">++</span>w<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>D<span class="token punctuation">)</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token punctuation">(</span><span class="token operator">*</span>D<span class="token punctuation">)</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">*</span>D<span class="token punctuation">)</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">/* 如果经过下标为 k 的顶点路径比原两点间路径更短 */</span>                    <span class="token punctuation">(</span><span class="token operator">*</span>D<span class="token punctuation">)</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>D<span class="token punctuation">)</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">*</span>D<span class="token punctuation">)</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 将当前两点间权值设为更小的一个 */</span>                    <span class="token punctuation">(</span><span class="token operator">*</span>P<span class="token punctuation">)</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>P<span class="token punctuation">)</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 路径设置为经过下标为 k 的顶点 */</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>打印各节点间的最短路径</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 打印各顶点间的最短路径 */</span><span class="token keyword">void</span> <span class="token function">ShowShortestPath</span><span class="token punctuation">(</span>MGraph G<span class="token punctuation">,</span> Patharc <span class="token operator">*</span>P<span class="token punctuation">,</span> ShortPathTable <span class="token operator">*</span>D<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> v <span class="token operator">&lt;</span> G<span class="token punctuation">.</span>numVertexes<span class="token punctuation">;</span> <span class="token operator">++</span>v<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> w <span class="token operator">=</span> v <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> w <span class="token operator">&lt;</span> G<span class="token punctuation">.</span>numVertexes<span class="token punctuation">;</span> <span class="token operator">++</span>w<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"v%d-v%d weight: %d "</span><span class="token punctuation">,</span>v<span class="token punctuation">,</span>w<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">*</span>D<span class="token punctuation">)</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>P<span class="token punctuation">)</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 获得第一个路径顶点下标 */</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" path: %d"</span><span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 打印源点 */</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">!=</span> w<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">/* 如果路径顶点下标不是终点 */</span>            <span class="token punctuation">{</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" -> %d"</span><span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 打印路径顶点 */</span>                k <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>P<span class="token punctuation">)</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 获得下一个路径顶点下标 */</span>            <span class="token punctuation">}</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" -> %d\n"</span><span class="token punctuation">,</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 打印终点 */</span>        <span class="token punctuation">}</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 大话数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大话数据结构 </tag>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.6 最小生成树</title>
      <link href="/2019/10/25/7.6-zui-xiao-sheng-cheng-shu/"/>
      <url>/2019/10/25/7.6-zui-xiao-sheng-cheng-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="7-6-最小生成树"><a href="#7-6-最小生成树" class="headerlink" title="7.6 最小生成树"></a>7.6 最小生成树</h1><blockquote><p>什么是最小生成树呢？</p></blockquote><h2 id="什么是最小生成树呢？"><a href="#什么是最小生成树呢？" class="headerlink" title="什么是最小生成树呢？"></a>什么是最小生成树呢？</h2><p>即构造连通图的最小代价生成树，就是能够到达每个点，花费最少的路径</p><h2 id="7-6-1-Prim算法"><a href="#7-6-1-Prim算法" class="headerlink" title="7.6.1 Prim算法"></a>7.6.1 Prim算法</h2><p><img src="https://s2.ax1x.com/2019/10/25/Kw73hd.jpg" alt="Kw73hd.jpg"></p><h3 id="1-代码："><a href="#1-代码：" class="headerlink" title="1.代码："></a>1.代码：</h3><h3 id="邻接矩阵结构："><a href="#邻接矩阵结构：" class="headerlink" title="邻接矩阵结构："></a>邻接矩阵结构：</h3><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> MAXVER 10</span><span class="token keyword">typedef</span> <span class="token keyword">char</span> VertexType<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>    VertexType vexs<span class="token punctuation">[</span>MAXVER<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> arc<span class="token punctuation">[</span>MAXVER<span class="token punctuation">]</span><span class="token punctuation">[</span>MAXVER<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> numVertexes<span class="token punctuation">,</span> numEdges<span class="token punctuation">;</span><span class="token punctuation">}</span>MGraph<span class="token punctuation">;</span></code></pre><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* Prim 算法生成最小生成树 */</span><span class="token keyword">void</span> <span class="token function">MiniSpanTree_Prim</span><span class="token punctuation">(</span>MGraph G<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> min<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// min 为当前权值最小值</span>    <span class="token keyword">int</span> lowcost<span class="token punctuation">[</span>MAXVEX<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 保存顶点间边的权值 */</span>    <span class="token keyword">int</span> adjvex<span class="token punctuation">[</span>MAXVEX<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 保存相关顶点的下标，即下标与其值所连边为当前最小权值边 */</span>    lowcost<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 选取第一个顶点为起始点， 即 v0 加入树， lowcost的值为0，在这里就是此下标的顶点已经加入生成树 */</span>    adjvex<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 初始化第一个顶点下标为0 */</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> G<span class="token punctuation">.</span>numVertexes<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">/* 循环除下标为 0 外的全部顶点 */</span>    <span class="token punctuation">{</span>        lowcost<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> G<span class="token punctuation">.</span>arc<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 将与 v0 顶点有边的权值存入数组 */</span>        adjvex<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 将其他所有顶点的值初始化为 v0 的下标 */</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> G<span class="token punctuation">.</span>numVertexes<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        min <span class="token operator">=</span> INF<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 初始化最小权值为 无穷大 */</span>        j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">&lt;</span> G<span class="token punctuation">.</span>numVertexes<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">/* 循环全部顶点，寻找当前最小生成树顶点集合中最小权值的边 */</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> min<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">/* 如果权值不为 0(即不在树中), 且权值小于 min */</span>            <span class="token punctuation">{</span>                min <span class="token operator">=</span> lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 则让当前权值成为最小值 */</span>                k <span class="token operator">=</span> j<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">/* 将当前最小值的下标存入k */</span>            <span class="token punctuation">}</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        lowcost<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 将当前顶点的权值设置为0, 表示此顶点已加入树的顶点集合 */</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"(%d, %d)"</span><span class="token punctuation">,</span> adjvex<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 打印当前顶点边中权值最小的边 */</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> G<span class="token punctuation">.</span>numVertexes<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">/* 循环所有顶点 */</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/* 如果下标为 k 的顶点边集中权值小于已存在的权值, 比如 (v0, v6)权值为INF, 而(v1, v6)权值为 16， 更新*/</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> G<span class="token punctuation">.</span>arc<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> G<span class="token punctuation">.</span>arc<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 将较小的权值存入 lowcost 相应位置 */</span>                adjvex<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> k<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 将下标为 k 的顶点存入 adjvex */</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>lowcost其实存着最小的权,当lowcost==0的时候，说明该结点已经放入最小生成树中了</p><p>adjvex其实存在点，</p><h3 id="2-复杂度"><a href="#2-复杂度" class="headerlink" title="2.复杂度"></a>2.复杂度</h3><p>时间复杂度是O（n2）</p><h2 id="7-6-2-Kruskal算法"><a href="#7-6-2-Kruskal算法" class="headerlink" title="7.6.2 Kruskal算法"></a>7.6.2 Kruskal算法</h2><h3 id="1-什么是克鲁斯卡尔算法"><a href="#1-什么是克鲁斯卡尔算法" class="headerlink" title="1.什么是克鲁斯卡尔算法"></a>1.什么是克鲁斯卡尔算法</h3><p>按照<strong>权值从小到大</strong>的顺序选择<code>n - 1</code>条边，并保证这<code>n - 1</code>条边<strong>不构成回路</strong></p><h3 id="2-思路是怎样的？"><a href="#2-思路是怎样的？" class="headerlink" title="2.思路是怎样的？"></a>2.思路是怎样的？</h3><ol><li>将邻接矩阵转化为边集数组</li><li>构造一个只含<code>n</code>个顶点的森林，</li><li>然后<strong>依权值从小到大</strong>从连通网中选择边加入到森林中，并使森林<strong>不产生回路</strong>，直至森林变成过一棵树为止</li></ol><p><img src="https://s2.ax1x.com/2019/10/25/KwbbTO.jpg" alt="KwbbTO.jpg"></p><h3 id="3-具体算法"><a href="#3-具体算法" class="headerlink" title="3.具体算法"></a>3.具体算法</h3><p>边集数组结构</p><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> begin<span class="token punctuation">;</span>    <span class="token keyword">int</span> end<span class="token punctuation">;</span>    <span class="token keyword">int</span> weight<span class="token punctuation">;</span><span class="token punctuation">}</span>Edge<span class="token punctuation">;</span></code></pre><p>算法</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 生成最小生成树 */</span><span class="token keyword">void</span> <span class="token function">MiniSpanTree_Kruskal</span><span class="token punctuation">(</span>MGraph G<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span>    <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> parent<span class="token punctuation">[</span>MAXVEX<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 定义一数组用来判断边与边是否形成环路 */</span>    Edge edges<span class="token punctuation">[</span>MAXEDGE<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 定义边集数组,edge的结构为begin,end,weight,均为整型 */</span>    <span class="token comment" spellcheck="true">/* 用来构建边集数组并排序********************* */</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> G<span class="token punctuation">.</span>numVertexes <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> G<span class="token punctuation">.</span>numVertexes<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>G<span class="token punctuation">.</span>arc<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> INF<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                edges<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>begin <span class="token operator">=</span> i<span class="token punctuation">;</span>                edges<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>end <span class="token operator">=</span> j<span class="token punctuation">;</span>                edges<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>weight <span class="token operator">=</span> G<span class="token punctuation">.</span>arc<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                k<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">sort</span><span class="token punctuation">(</span>edges<span class="token punctuation">,</span> <span class="token operator">&amp;</span>G<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* ******************************************* */</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"打印最小生成树：\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> G<span class="token punctuation">.</span>numVertexes<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        parent<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 初始化数组值为0 */</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> G<span class="token punctuation">.</span>numEdges<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">/* 循环每一条边 */</span>    <span class="token punctuation">{</span>        n <span class="token operator">=</span> <span class="token function">Find</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>begin<span class="token punctuation">)</span><span class="token punctuation">;</span>        m <span class="token operator">=</span> <span class="token function">Find</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">!=</span> m<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">/* 假如n与m不等，说明此边没有与现有的生成树形成环路 */</span>        <span class="token punctuation">{</span>            parent<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> m<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 将此边的结尾顶点放入下标为起点的parent中。 表示此顶点已经在生成树集合中*/</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"(%d, %d) %d\n"</span><span class="token punctuation">,</span> edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>begin<span class="token punctuation">,</span> edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>end<span class="token punctuation">,</span> edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//Kruskal（克鲁斯卡尔算法）生成最小生成树</span><span class="token keyword">int</span> <span class="token function">Find</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>parent<span class="token punctuation">,</span> <span class="token keyword">int</span> f<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">while</span><span class="token punctuation">(</span>parent<span class="token punctuation">[</span>f<span class="token punctuation">]</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span>   <span class="token punctuation">{</span>       f <span class="token operator">=</span> parent<span class="token punctuation">[</span>f<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">return</span> f<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>其中，如果已经加入的话，parent[5]=8表示(5,8)在边集合里面</p>]]></content>
      
      
      <categories>
          
          <category> 大话数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大话数据结构 </tag>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.5 图的遍历</title>
      <link href="/2019/10/25/7.5-tu-de-bian-li/"/>
      <url>/2019/10/25/7.5-tu-de-bian-li/</url>
      
        <content type="html"><![CDATA[<h1 id="7-5-图的遍历"><a href="#7-5-图的遍历" class="headerlink" title="7.5 图的遍历"></a>7.5 图的遍历</h1><h2 id="7-5-1-深度优先遍历"><a href="#7-5-1-深度优先遍历" class="headerlink" title="7.5.1 深度优先遍历"></a>7.5.1 深度优先遍历</h2><h3 id="1-什么是深度优先遍历呢"><a href="#1-什么是深度优先遍历呢" class="headerlink" title="1.什么是深度优先遍历呢?"></a>1.什么是深度优先遍历呢?</h3><p>深度优先遍历（Depth_First_Search)，也称为深度优先搜索，简称DFS</p><p>从图中某个顶点<code>v</code>出发，访问此顶点，然后从<code>v</code>的未被访问的邻接点出发深度优先遍历图，直至图中所有和<code>v</code>有路径想通的顶点都被访问到。若图中尚有顶点未被访问到，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。显然，深度优先遍历是一个 <strong>递归</strong>的过程，类似于树的前序遍历</p><p>打个比方，就是一个房间无死角地找，找完再去下一个房间</p><p><img src="https://i.loli.net/2019/10/25/4bxnUeEVWDO9dcm.jpg" alt></p><ul><li>顶点A出发，访问A， 假设没有碰到重复顶点的情况下，始终向右手边走</li><li>访问A的邻接点B， B的邻接点C， C的邻接点D， D的邻接点E， E的邻接点F</li><li>在顶点F处，右手边为顶点A，但已被访问过，故访问顶点G</li><li>在顶点G处，右手边为顶点B，下一个为D， 都已被访问，故访问顶点H</li><li>在顶点H处，由于邻接点G、D和E都被访问，故回退到G，同理，一直回退到D处，访问I</li></ul><h3 id="2-邻接矩阵的方式深度遍历的算法是怎样的？"><a href="#2-邻接矩阵的方式深度遍历的算法是怎样的？" class="headerlink" title="2.邻接矩阵的方式深度遍历的算法是怎样的？"></a>2.邻接矩阵的方式深度遍历的算法是怎样的？</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">int</span> Boolean<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* Boolean 是布尔类型， 其值是 TRUE 或 FALSE */</span>Boolean visited<span class="token punctuation">[</span>MAX<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 访问标志的数组 */</span><span class="token comment" spellcheck="true">/* 邻接矩阵的深度优先递归算法 */</span><span class="token keyword">void</span> <span class="token function">DFS</span><span class="token punctuation">(</span>MGraph G<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%C "</span><span class="token punctuation">,</span> G<span class="token punctuation">.</span>vexs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 打印顶点，也可以是其他操作 */</span>    visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> TRUE<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> G<span class="token punctuation">.</span>numVertexes<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>G<span class="token punctuation">.</span>arc<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>visited<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token function">DFS</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 对未访问的邻接顶点递归调用 */</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 邻接矩阵的深度遍历操作 */</span><span class="token keyword">void</span> <span class="token function">DFSTraverse</span><span class="token punctuation">(</span>MGraph G<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> G<span class="token punctuation">.</span>numVertexes<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> FALSE<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 初始所有顶点状态都是未访问过状态 */</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> G<span class="token punctuation">.</span>numVertexes<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">/* 对未访问过的顶点调用 DFS， 若是连通图，只会执行一次 */</span>            <span class="token function">DFS</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>注意，void DFSTraverse(MGraph G)中的第二个循环，主要是为了遍历非连通图的情况</p><h3 id="3-邻接表的深度遍历的算法是怎样的？"><a href="#3-邻接表的深度遍历的算法是怎样的？" class="headerlink" title="3.邻接表的深度遍历的算法是怎样的？"></a>3.邻接表的深度遍历的算法是怎样的？</h3><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 邻接表的深度优先递归算法 */</span><span class="token keyword">void</span> <span class="token function">DFS</span><span class="token punctuation">(</span>GraphAdjList GL<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c "</span><span class="token punctuation">,</span> GL<span class="token punctuation">.</span>adjList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> TRUE<span class="token punctuation">;</span>    EdgeNode <span class="token operator">*</span>p <span class="token operator">=</span> GL<span class="token punctuation">.</span>adjList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>firstedge<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">visited</span><span class="token punctuation">(</span>p<span class="token operator">-></span>adjvex<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token function">DFS</span><span class="token punctuation">(</span>GL<span class="token punctuation">,</span> p<span class="token operator">-></span>adjvex<span class="token punctuation">)</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 邻接表的深度遍历操作 */</span><span class="token keyword">void</span> <span class="token function">DFSTraverse</span><span class="token punctuation">(</span>GraphAdjList GL<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> GL<span class="token punctuation">.</span>numVertexes<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> TRUE<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> GL<span class="token punctuation">.</span>numVertexes<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token function">DFS</span><span class="token punctuation">(</span>GL<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="4-邻接表和邻接矩阵二者哪个好"><a href="#4-邻接表和邻接矩阵二者哪个好" class="headerlink" title="4.邻接表和邻接矩阵二者哪个好"></a>4.邻接表和邻接矩阵二者哪个好</h3><p>如果是点多边少的话，用邻接表比较好</p><h2 id="7-5-2-广度优先遍历"><a href="#7-5-2-广度优先遍历" class="headerlink" title="7.5.2 广度优先遍历"></a>7.5.2 广度优先遍历</h2><h3 id="1-什么是广度优先遍历"><a href="#1-什么是广度优先遍历" class="headerlink" title="1.什么是广度优先遍历"></a>1.什么是<strong>广度优先遍历</strong></h3><p><strong>广度优先遍历(Breadth First Search)</strong>，又称为 <strong>广度优先搜索</strong>， 简称 <strong>BFS</strong>。</p><p>思想：</p><p>从图中某个顶点<code>v</code>出发，在访问了顶点<code>v</code>后，依次访问顶点<code>v</code>的所有未被访问过的邻接点，然后分别从这些邻接点依次访问他们的邻接点，并使得<code>先被访问过的顶点的邻接点先于后被访问的顶点的邻接点被访问</code>， 直至图中所有已被访问的顶点的邻接点都被访问到。</p><p>类似于层序遍历</p><h3 id="2-图解"><a href="#2-图解" class="headerlink" title="2.图解"></a>2.图解</h3><p><img src="https://i.loli.net/2019/10/25/NpQqzhHudERPUSA.jpg" alt></p><p>核心思想是：出队一个，要把与它直接相连的都进队</p><p>比如说：第2步出队一个A，进队与他直接相连的B F</p><h3 id="3-代码："><a href="#3-代码：" class="headerlink" title="3.代码："></a>3.代码：</h3><h4 id="1-无向图的邻接矩阵"><a href="#1-无向图的邻接矩阵" class="headerlink" title="1.无向图的邻接矩阵"></a>1.无向图的邻接矩阵</h4><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">BFSTraverse</span><span class="token punctuation">(</span>MGraph G<span class="token punctuation">)</span><span class="token punctuation">{</span>    SqQueue Q<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> G<span class="token punctuation">.</span>numVertexes<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> FALSE<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 初始化辅助用的队列 */</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> G<span class="token punctuation">.</span>numVertexes<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">/* 对每一个顶点做循环 */</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">/* 若是未访问过就处理 */</span>        <span class="token punctuation">{</span>            <span class="token function">EnQueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Q<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 将此队列入队 */</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c "</span><span class="token punctuation">,</span> G<span class="token punctuation">.</span>vexs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 打印顶点，也可以是其他操作 */</span>            visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> TRUE<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 设置当前顶点访问过 */</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">QueueEmpty</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">/* 若当前队列不为空 */</span>            <span class="token punctuation">{</span>                <span class="token function">DeQueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Q<span class="token punctuation">,</span> <span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 将队列中元素出队列，赋值给 i */</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> G<span class="token punctuation">.</span>numVertexes<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">/* 判断其他顶点若与当前顶点存在边且未被访问过 */</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>G<span class="token punctuation">.</span>arc<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>visited<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                      <span class="token punctuation">{</span>                        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c "</span><span class="token punctuation">,</span> G<span class="token punctuation">.</span>vexs<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 打印顶点 */</span>                        visited<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> TRUE<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 将找到的此顶点标记为已访问 */</span>                        <span class="token function">EnQueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Q<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 将找到的此顶点入队 */</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>               <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="2-无向图的邻接表"><a href="#2-无向图的邻接表" class="headerlink" title="2.无向图的邻接表"></a>2.无向图的邻接表</h4><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 邻接表的广度遍历算法 */</span><span class="token keyword">void</span> <span class="token function">BFS</span><span class="token punctuation">(</span>GraphAdjList GL<span class="token punctuation">)</span><span class="token punctuation">{</span>    SqQueue Q<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> GL<span class="token punctuation">.</span>numVertexes<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> FALSE<span class="token punctuation">;</span>    <span class="token function">InitQueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> GL<span class="token punctuation">.</span>numVertexes<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">EnQueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Q<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> TRUE<span class="token punctuation">;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c "</span><span class="token punctuation">,</span> GL<span class="token punctuation">.</span>adjList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 打印顶点，也可以是其他操作 */</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">QueueEmpty</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token function">DeQueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Q<span class="token punctuation">,</span> <span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                NodeEdge <span class="token operator">*</span>p <span class="token operator">=</span> GL<span class="token punctuation">.</span>adjList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>firstedge<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 找到当前顶点边表链表头指针 */</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>p<span class="token operator">-></span>adjvex<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">/* 若此顶点未被访问 */</span>                    <span class="token punctuation">{</span>                        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c "</span><span class="token punctuation">,</span> G<span class="token punctuation">.</span>adjList<span class="token punctuation">[</span>p<span class="token operator">-></span>adjvex<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token function">EnQueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Q<span class="token punctuation">,</span> p<span class="token operator">-></span>adjvex<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 将此顶点入队 */</span>                        visited<span class="token punctuation">[</span>p<span class="token operator">-></span>adjvex<span class="token punctuation">]</span> <span class="token operator">=</span> TRUE<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 指针指向下一个邻接点 */</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="DFS和BFS哪个更好呢？"><a href="#DFS和BFS哪个更好呢？" class="headerlink" title="DFS和BFS哪个更好呢？"></a>DFS和BFS哪个更好呢？</h2><p>DFS适合目标更明确</p><p>BFS适合不断扩大范围找到相对最优解</p>]]></content>
      
      
      <categories>
          
          <category> 大话数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大话数据结构 </tag>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.4 图的存储结构</title>
      <link href="/2019/10/25/7.4-tu-de-cun-chu-jie-gou/"/>
      <url>/2019/10/25/7.4-tu-de-cun-chu-jie-gou/</url>
      
        <content type="html"><![CDATA[<h1 id="7-4-图的存储结构"><a href="#7-4-图的存储结构" class="headerlink" title="7.4 图的存储结构"></a>7.4 图的存储结构</h1><h2 id="7-4-1-邻接矩阵"><a href="#7-4-1-邻接矩阵" class="headerlink" title="7.4.1 邻接矩阵"></a>7.4.1 邻接矩阵</h2><h3 id="1-什么是邻接矩阵"><a href="#1-什么是邻接矩阵" class="headerlink" title="1.什么是邻接矩阵"></a>1.什么是邻接矩阵</h3><p>图的邻接矩阵存储方式是用两个数组来标示图。一个<strong>一维数组</strong>存储图<strong>顶点</strong>的信息，一个<strong>二维数组</strong>（称为邻接矩阵）存储图中<strong>边或者弧</strong>的信息。</p><h4 id="1-无向图的邻接矩阵："><a href="#1-无向图的邻接矩阵：" class="headerlink" title="1.无向图的邻接矩阵："></a>1.无向图的邻接矩阵：</h4><p><img src="https://i.loli.net/2019/10/25/81XwrqsD7CuzT3o.jpg" alt></p><h4 id="2-有向图的邻接矩阵："><a href="#2-有向图的邻接矩阵：" class="headerlink" title="2.有向图的邻接矩阵："></a>2.有向图的邻接矩阵：</h4><p><img src="https://i.loli.net/2019/10/25/XTVAmFcyEovWSMJ.jpg" alt></p><p>可以很容易看出，入度是多少（看列），出度是多少（看行）</p><h4 id="3-网图的邻接矩阵："><a href="#3-网图的邻接矩阵：" class="headerlink" title="3.网图的邻接矩阵："></a>3.网图的邻接矩阵：</h4><p>当2个点到达不了的，用无穷表示距离，当自己到自己的，用0表示距离</p><p><img src="https://i.loli.net/2019/10/25/nqPfX9szxOT63Lw.jpg" alt></p><h3 id="2-邻接矩阵的存储结构："><a href="#2-邻接矩阵的存储结构：" class="headerlink" title="2.邻接矩阵的存储结构："></a>2.邻接矩阵的存储结构：</h3><p><img src="https://i.loli.net/2019/10/25/QJplD6WanVSydCX.jpg" alt></p><h3 id="3-无向网图的创建："><a href="#3-无向网图的创建：" class="headerlink" title="3.无向网图的创建："></a>3.无向网图的创建：</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">CreateMGraph</span><span class="token punctuation">(</span>MGraph <span class="token operator">*</span>G<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>k<span class="token punctuation">,</span>w<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"输入顶点数和边数：\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d,%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>G<span class="token operator">-></span>numVertexes<span class="token punctuation">,</span><span class="token operator">&amp;</span>G<span class="token operator">-></span>numEdges<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输入顶点数和边数</span>    <span class="token keyword">for</span><span class="token punctuation">(</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>G<span class="token operator">-></span>numVertexes<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//初始化顶点表 </span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>G<span class="token operator">-></span>vex<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>G<span class="token operator">-></span>numVertexes<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>inj<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>G<span class="token operator">-></span>numVertexes<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            G<span class="token operator">-></span>arc<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>INFINITY<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//邻接矩阵初始化</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>k<span class="token operator">&lt;</span>G<span class="token operator">-></span>numEdges<span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"输入边(vi,vj)的下标i，j和权w：\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d,%d,%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>i<span class="token punctuation">,</span><span class="token operator">&amp;</span>j<span class="token punctuation">,</span><span class="token operator">&amp;</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输入边(vi,vj)的下标i，j和权w：</span>            G<span class="token operator">-></span>arc<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>w<span class="token punctuation">;</span>            G<span class="token operator">-></span>arc<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>G<span class="token operator">-></span>arc<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//因为是无向图，矩阵对称 </span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> </code></pre><h2 id="7-4-2-邻接表"><a href="#7-4-2-邻接表" class="headerlink" title="7.4.2 邻接表"></a>7.4.2 邻接表</h2><h3 id="1-什么是邻接表？"><a href="#1-什么是邻接表？" class="headerlink" title="1.什么是邻接表？"></a>1.什么是邻接表？</h3><p>用<strong>数组和链表结合</strong>的存储方式来标示图的方法称为<strong>邻接表</strong>。类似于树中的孩子表示法</p><h3 id="2-邻接表的处理思路"><a href="#2-邻接表的处理思路" class="headerlink" title="2.邻接表的处理思路"></a>2.邻接表的处理思路</h3><ol><li><strong>顶点用一维数组</strong>存储</li><li>每个顶点的<strong>邻接点用链表</strong>存储，这个表在<strong>有向图</strong>中叫做弧尾的<strong>出边表</strong>，在<strong>无向图</strong>中叫<strong>边表</strong></li></ol><p><img src="https://i.loli.net/2019/10/25/CoyZhOaBTIfmr84.jpg" alt></p><h3 id="3-邻接表结构分析"><a href="#3-邻接表结构分析" class="headerlink" title="3.邻接表结构分析"></a>3.邻接表结构分析</h3><p><strong>data</strong>是存储<strong>顶点的信息</strong>，<strong>firstedge</strong>是<strong>指针域</strong>，<strong>adjvex</strong>是<strong>邻接点域</strong>，<strong>next</strong>存储边表<strong>下一个结点的地址</strong></p><h3 id="4-带权重的网图是怎样的？"><a href="#4-带权重的网图是怎样的？" class="headerlink" title="4.带权重的网图是怎样的？"></a>4.带权重的网图是怎样的？</h3><p><img src="https://i.loli.net/2019/10/25/UtC1jmIGQEqporL.jpg" alt></p><p><img src="https://i.loli.net/2019/10/25/nlSpAICoqc3Fr2d.jpg" alt></p><h3 id="5-存储结构定义："><a href="#5-存储结构定义：" class="headerlink" title="5.存储结构定义："></a>5.存储结构定义：</h3><p><img src="https://i.loli.net/2019/10/25/jyEYkXLFcPe6tW9.jpg" alt></p><h3 id="6-无向图邻接表的创建代码："><a href="#6-无向图邻接表的创建代码：" class="headerlink" title="6.无向图邻接表的创建代码："></a>6.无向图邻接表的创建代码：</h3><p><img src="https://i.loli.net/2019/10/25/jMaQtV8RBcuKmk9.jpg" alt></p><p><img src="https://i.loli.net/2019/10/25/4QPOBge6WCywHbk.jpg" alt></p><p>因为一条边对应了2个顶点，所以一次循环插入2条边</p><h2 id="7-4-3-十字链表"><a href="#7-4-3-十字链表" class="headerlink" title="7.4.3 十字链表"></a>7.4.3 十字链表</h2><h3 id="1-什么是十字链表"><a href="#1-什么是十字链表" class="headerlink" title="1.什么是十字链表"></a>1.什么是十字链表</h3><p>十字链表把邻接表与逆邻接表结合起来</p><h3 id="2-十字链表的结构是怎样的？"><a href="#2-十字链表的结构是怎样的？" class="headerlink" title="2.十字链表的结构是怎样的？"></a>2.十字链表的结构是怎样的？</h3><p><img src="https://i.loli.net/2019/10/25/l3NMa6KIcWnOeQV.jpg" alt></p><p><img src="https://i.loli.net/2019/10/25/zrt8YwxTEG7h5HW.jpg" alt></p><p>注意的是：headlink是指向终点相同的下一条边，taillink是指向起点相同的下一条边</p><h3 id="3-有什么好处？"><a href="#3-有什么好处？" class="headerlink" title="3.有什么好处？"></a>3.有什么好处？</h3><p>便于求出度和入度</p><h2 id="7-4-4-邻接多重表"><a href="#7-4-4-邻接多重表" class="headerlink" title="7.4.4 邻接多重表"></a>7.4.4 邻接多重表</h2><h3 id="1-为什么要设计邻接多重表呢？"><a href="#1-为什么要设计邻接多重表呢？" class="headerlink" title="1.为什么要设计邻接多重表呢？"></a>1.为什么要设计邻接多重表呢？</h3><p>其实是为了便于边的操作，一条边对应一个结点</p><h3 id="2-邻接多重表的结构是怎样的？"><a href="#2-邻接多重表的结构是怎样的？" class="headerlink" title="2.邻接多重表的结构是怎样的？"></a>2.邻接多重表的结构是怎样的？</h3><p><img src="https://i.loli.net/2019/10/25/v2D3gjczXla5IOP.jpg" alt></p><p>注意的是：ilink与jvex相连，jlink与ivex相连</p><p><img src="https://i.loli.net/2019/10/25/irCVB1XcYu5fvqx.jpg" alt></p><p>如果想要去掉（v0,v2）这条边，只需要把6和9的连接改为null就行</p><h2 id="7-4-5-边集数组"><a href="#7-4-5-边集数组" class="headerlink" title="7.4.5 边集数组"></a>7.4.5 边集数组</h2><h3 id="1-边集数组的结构是怎样的？"><a href="#1-边集数组的结构是怎样的？" class="headerlink" title="1.边集数组的结构是怎样的？"></a>1.边集数组的结构是怎样的？</h3><p><img src="https://i.loli.net/2019/10/25/jnCNfa5JkvoZQmh.jpg" alt></p><p><img src="https://i.loli.net/2019/10/25/dChOJexVnzFvof3.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 大话数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大话数据结构 </tag>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.12 赫夫曼树及其应用</title>
      <link href="/2019/10/24/6.12-he-fu-man-shu-ji-qi-ying-yong/"/>
      <url>/2019/10/24/6.12-he-fu-man-shu-ji-qi-ying-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="6-12-赫夫曼树及其应用"><a href="#6-12-赫夫曼树及其应用" class="headerlink" title="6.12 赫夫曼树及其应用"></a>6.12 赫夫曼树及其应用</h1><blockquote><p>用来干什么呢？其实就是最基本的压缩算法</p></blockquote><h2 id="6-12-2-赫夫曼树定义和原理"><a href="#6-12-2-赫夫曼树定义和原理" class="headerlink" title="6.12.2 赫夫曼树定义和原理"></a>6.12.2 赫夫曼树定义和原理</h2><h3 id="1-什么是路径，什么是路径长度"><a href="#1-什么是路径，什么是路径长度" class="headerlink" title="1.什么是路径，什么是路径长度"></a>1.什么是路径，什么是路径长度</h3><p>路径就是：从树中一个结点到另一个结点之间的分支</p><p>路径长度是：路径上的分支数目</p><p>树的路径长度是：从树根到一每结点的路径长度之和。</p><p><img src="https://i.loli.net/2019/10/24/tkaxuSOz57sfHL2.jpg" alt></p><p>比如上图，根节点到A的路径长度是3，树的路径长度=1+2+3+3+2+1=12</p><h3 id="2-什么是带权路径长度"><a href="#2-什么是带权路径长度" class="headerlink" title="2.什么是带权路径长度"></a>2.什么是带权路径长度</h3><p>就是路径长度*权值，上面的树的带权路径长度=3 *5+3 *15+2 *70+1 *10</p><h3 id="3-什么是赫夫曼树"><a href="#3-什么是赫夫曼树" class="headerlink" title="3.什么是赫夫曼树"></a>3.什么是赫夫曼树</h3><p>带权路径长度WPL最小的二叉树称作赫夫曼树</p><h3 id="4-怎么构造赫夫曼树呢？"><a href="#4-怎么构造赫夫曼树呢？" class="headerlink" title="4.怎么构造赫夫曼树呢？"></a>4.怎么构造赫夫曼树呢？</h3><ol><li><p>在森林中选出两颗根结点的权值最小的二叉树。</p></li><li><p>合并两棵树，增加一个新结点作为新二叉树的根，权值为左右孩子的权重之和。</p></li><li><p>再从未选中的结点中选择一个最小的，和第2步的结点比较，小的放左边，大的放右边，然后重复，一直到结点没有了为止</p><p>具体如下图所示</p></li></ol><p><img src="https://i.loli.net/2019/10/24/EJ57lqokSVDbrfp.jpg" alt></p><h2 id="6-12-3-赫夫曼编码"><a href="#6-12-3-赫夫曼编码" class="headerlink" title="6.12.3 赫夫曼编码"></a>6.12.3 赫夫曼编码</h2><h3 id="1-什么是赫夫曼编码"><a href="#1-什么是赫夫曼编码" class="headerlink" title="1.什么是赫夫曼编码"></a>1.什么是赫夫曼编码</h3><p>其实是一种<strong>按照赫夫曼树定义的编码规则</strong>，出现多的字符的编码比较短，反之比较长，赫夫曼编码可以节省空间</p><h3 id="2-怎么生成赫夫曼编码呢？"><a href="#2-怎么生成赫夫曼编码呢？" class="headerlink" title="2.怎么生成赫夫曼编码呢？"></a>2.怎么生成赫夫曼编码呢？</h3><p>先把一系列数字转换成<strong>赫夫曼树</strong>，然后将权值<strong>左分支改为0</strong>，<strong>右分支改为1</strong>，得到下图：</p><p><img src="https://i.loli.net/2019/10/24/xfmdUTr32nL6CBF.jpg" alt></p><p>然后用<strong>树根到叶子所经过路径的0或者1来编码</strong>，比如B的编码是1001</p><p><img src="https://i.loli.net/2019/10/24/bIkjSQWZDxrm4EF.jpg" alt></p><h3 id="3-怎么由赫夫曼编码解码呢？"><a href="#3-怎么由赫夫曼编码解码呢？" class="headerlink" title="3.怎么由赫夫曼编码解码呢？"></a>3.怎么由赫夫曼编码解码呢？</h3><ol><li>先得到已知的赫夫曼树</li><li>按照数字对着赫夫曼树逐个查找就可以了</li></ol><p>比如说10010100101是什么？</p><p>B A D C</p>]]></content>
      
      
      <categories>
          
          <category> 大话数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大话数据结构 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.10 线索二叉树</title>
      <link href="/2019/10/24/6.10-xian-suo-er-cha-shu/"/>
      <url>/2019/10/24/6.10-xian-suo-er-cha-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="6-10-线索二叉树"><a href="#6-10-线索二叉树" class="headerlink" title="6.10 线索二叉树"></a>6.10 线索二叉树</h1><h2 id="6-10-1-线索二叉树的原理"><a href="#6-10-1-线索二叉树的原理" class="headerlink" title="6.10.1  线索二叉树的原理"></a>6.10.1  线索二叉树的原理</h2><h3 id="1-普通的二叉树存在什么浪费空间的地方吗？"><a href="#1-普通的二叉树存在什么浪费空间的地方吗？" class="headerlink" title="1.普通的二叉树存在什么浪费空间的地方吗？"></a>1.普通的二叉树存在什么浪费空间的地方吗？</h3><p>对于有n个结点的二叉树，空链域却有n+1个</p><h3 id="2-怎么利用那些浪费的空间呢"><a href="#2-怎么利用那些浪费的空间呢" class="headerlink" title="2.怎么利用那些浪费的空间呢?"></a>2.怎么利用那些浪费的空间呢?</h3><p>因此，提出了一种方法，利用原来的<strong>空链域存放指针</strong>，指向树中其他结点。我们把指向前驱后继的这种指针称为线索。</p><p>相应的二叉树就是线索二叉树</p><h3 id="3-怎么知道某一个结点的lchild是指向左孩子还是前驱呢？"><a href="#3-怎么知道某一个结点的lchild是指向左孩子还是前驱呢？" class="headerlink" title="3.怎么知道某一个结点的lchild是指向左孩子还是前驱呢？"></a>3.怎么知道某一个结点的lchild是指向左孩子还是前驱呢？</h3><p>其实思路很简单，<strong>加个标记</strong>就行，0表示孩子，1表示前驱或者后继</p><p><img src="https://i.loli.net/2019/10/24/9DdJ51EHlzPi4aV.jpg" alt></p><p>修改后的二叉树是怎样的？</p><p><img src="https://i.loli.net/2019/10/24/i4QtNHmd5pqErVw.jpg" alt></p><h2 id="6-10-2-线索二叉树结构实现"><a href="#6-10-2-线索二叉树结构实现" class="headerlink" title="6.10.2 线索二叉树结构实现"></a>6.10.2 线索二叉树结构实现</h2><h3 id="1-线索二叉树存储结构是怎样的？"><a href="#1-线索二叉树存储结构是怎样的？" class="headerlink" title="1.线索二叉树存储结构是怎样的？"></a>1.线索二叉树存储结构是怎样的？</h3><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 二叉树的二叉线索存储结构定义*/</span><span class="token keyword">typedef</span> <span class="token keyword">enum</span><span class="token punctuation">{</span>Link<span class="token punctuation">,</span> Thread<span class="token punctuation">}</span>PointerTag<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//Link = 0表示指向左右孩子指针；Thread = 1表示指向前驱或后继的线索</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> BitNode<span class="token punctuation">{</span>       <span class="token keyword">char</span> data<span class="token punctuation">;</span>                                      <span class="token comment" spellcheck="true">//结点数据</span>       <span class="token keyword">struct</span> BitNode <span class="token operator">*</span>lchild<span class="token punctuation">,</span> <span class="token operator">*</span>rchild<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//左右孩子指针</span>       PointerTag  Ltag<span class="token punctuation">;</span>                               <span class="token comment" spellcheck="true">//左右标志</span>       PointerTag  rtal<span class="token punctuation">;</span><span class="token punctuation">}</span>BitNode<span class="token punctuation">,</span> <span class="token operator">*</span>BiTree<span class="token punctuation">;</span></code></pre><h3 id="2-怎么将普通二叉树转换为线索二叉树呢？"><a href="#2-怎么将普通二叉树转换为线索二叉树呢？" class="headerlink" title="2.怎么将普通二叉树转换为线索二叉树呢？"></a>2.怎么将普通二叉树转换为线索二叉树呢？</h3><p>其实<strong>线索化的实质</strong>是将二叉链表中的<strong>空指针改为指向前驱或后继</strong>的线索。</p><p><strong>中序遍历线索化</strong>的代码：</p><pre class=" language-c"><code class="language-c">BiTree pre<span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">//全局变量，始终指向刚刚访问过的结点</span><span class="token comment" spellcheck="true">//中序遍历进行中序线索化</span><span class="token keyword">void</span> <span class="token function">InThreading</span><span class="token punctuation">(</span>BiTree p<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">InThreading</span><span class="token punctuation">(</span>p<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//递归左子树线索化</span>        <span class="token comment" spellcheck="true">//  中序遍历的是printf("%c",T->data);//显示结点数据</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token operator">-></span>lchild<span class="token punctuation">)</span>           <span class="token comment" spellcheck="true">//当前结点没有左孩子</span>        <span class="token punctuation">{</span>            p<span class="token operator">-></span>ltag <span class="token operator">=</span> Thread<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//前驱线索</span>            p<span class="token operator">-></span>lchild <span class="token operator">=</span> pre<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//左孩子指针指向前驱</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>pre<span class="token operator">-></span>rchild<span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">//前驱结点没有右孩子</span>        <span class="token punctuation">{</span>            pre<span class="token operator">-></span>rtag <span class="token operator">=</span> Thread<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//后继线索</span>            pre<span class="token operator">-></span>rchild <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//前驱右孩子指针指向后继(当前结点p)</span>        <span class="token punctuation">}</span>        pre <span class="token operator">=</span> p<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//往上走</span>        <span class="token function">InThreading</span><span class="token punctuation">(</span>p<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//递归右子树线索化</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="1-为什么后继的遍历要用前驱结点没有右孩子来判断呢？"><a href="#1-为什么后继的遍历要用前驱结点没有右孩子来判断呢？" class="headerlink" title="1.为什么后继的遍历要用前驱结点没有右孩子来判断呢？"></a>1.为什么后继的遍历要用前驱结点没有右孩子来判断呢？</h4><p>因为当前结点的后继还没有访问到，所以用前驱结点的后继来实现</p><h4 id="2-这里中序遍历线索化的代码和中序遍历有什么相同点呢？"><a href="#2-这里中序遍历线索化的代码和中序遍历有什么相同点呢？" class="headerlink" title="2.这里中序遍历线索化的代码和中序遍历有什么相同点呢？"></a>2.这里中序遍历线索化的代码和中序遍历有什么相同点呢？</h4><p>其实这里只是用改变空指针的代码代替了中序遍历中打印结点的代码</p><h3 id="3-怎么遍历线索二叉树呢？"><a href="#3-怎么遍历线索二叉树呢？" class="headerlink" title="3.怎么遍历线索二叉树呢？"></a>3.怎么遍历线索二叉树呢？</h3><p>类似遍历双向链表的方法，加个头指针</p><p><img src="https://i.loli.net/2019/10/24/hMZevPtKx1LRX48.jpg" alt></p><p>代码是怎样的？</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//t指向头结点，头结点左链lchild指向根结点，头结点右链rchild指向中序遍历的最后一个结点。</span><span class="token comment" spellcheck="true">//中序遍历二叉线索树表示二叉树t</span><span class="token keyword">int</span> <span class="token function">InOrderThraverse_Thr</span><span class="token punctuation">(</span>BiTree t<span class="token punctuation">)</span><span class="token punctuation">{</span>    BiTree p<span class="token punctuation">;</span>    p <span class="token operator">=</span> t<span class="token operator">-></span>lchild<span class="token punctuation">;</span>                               <span class="token comment" spellcheck="true">//p指向根结点</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> t<span class="token punctuation">)</span>                               <span class="token comment" spellcheck="true">//空树或遍历结束时p == t</span>    <span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">-></span>ltag <span class="token operator">==</span> Link<span class="token punctuation">)</span>                       <span class="token comment" spellcheck="true">//当ltag = 0时循环到中序序列的第一个结点，到达最底部结点</span>        <span class="token punctuation">{</span>            p <span class="token operator">=</span> p<span class="token operator">-></span>lchild<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c "</span><span class="token punctuation">,</span> p<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token comment" spellcheck="true">//显示结点数据，可以更改为其他对结点的操作</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">-></span>rtag <span class="token operator">==</span> Thread <span class="token operator">&amp;&amp;</span> p<span class="token operator">-></span>rchild <span class="token operator">!=</span> t<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//当右指针指向后继的时候，循环打印</span>        <span class="token punctuation">{</span>            p <span class="token operator">=</span> p<span class="token operator">-></span>rchild<span class="token punctuation">;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c "</span><span class="token punctuation">,</span> p<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>rchild<span class="token punctuation">;</span>                         <span class="token comment" spellcheck="true">//p进入其右子树</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> OK<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>什么时候使用线索二叉树呢？</p><p>当需要经常遍历或者查找结点的时候，可以用线索二叉树</p>]]></content>
      
      
      <categories>
          
          <category> 大话数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大话数据结构 </tag>
            
            <tag> 树 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口和接口回调</title>
      <link href="/2019/10/23/jie-kou-he-jie-kou-hui-diao/"/>
      <url>/2019/10/23/jie-kou-he-jie-kou-hui-diao/</url>
      
        <content type="html"><![CDATA[<h1 id="接口和接口回调"><a href="#接口和接口回调" class="headerlink" title="接口和接口回调"></a>接口和接口回调</h1><h2 id="1-什么是接口·"><a href="#1-什么是接口·" class="headerlink" title="1.什么是接口·"></a>1.什么是接口·</h2><p>一种规范，一种规则，比如说，如果你是鸟，你就一定会飞，这里，鸟其实可以简单看成1个接口，会飞，可以看成接口里面的一个方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Bird</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//有两条腿</span>    <span class="token keyword">void</span> <span class="token function">haveTwoLegs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Swallow</span> <span class="token keyword">implements</span> <span class="token class-name">Bird</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我是燕子我会飞"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">haveTwoLegs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我是燕子我有2条腿"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="2-接口的作用"><a href="#2-接口的作用" class="headerlink" title="2.接口的作用"></a>2.接口的作用</h2><ul><li><p>实现了高内聚</p><p>其实就是通过接口，把使用细节封装起来，向外展示的是一个方法而已，类似于说明书的作用</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Chat</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//这样就声明这个聊天的功能有2个，让别人一看就知道</span>    <span class="token comment" spellcheck="true">//发消息</span>    <span class="token keyword">void</span> <span class="token function">sendMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//收消息</span>    <span class="token keyword">void</span> <span class="token function">getMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Class <span class="token class-name">GroupChat</span> <span class="token keyword">implements</span> <span class="token class-name">Chat</span><span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">sendMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>很多行代码    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">getMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>很多行代码    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>低耦合</p><p>我也不是很明白</p><p>百度说的</p><p>其次是接口的松耦合是我们可以编写可复性高的代码。比如Server层本来引用使用Dao层mysql数据库的实现类，现在遇到mysql解决不了的业务，需要orcale实现，难道你要为了这一个或几个的功能，把所有的引用mysql的全删掉重写？只要再写一个dao层的实现类去引用这个接口，遇到需要orcale方法使用哪个接口变量就好了，别人写的代码也无需去删改。抽象类可以再写一个子类，但子类却不受父类过多约束，随意添加方法，对于项目的协同工作不利。抽象类做不到==对修改封闭，对扩展开放==的原则。<br>————————————————<br>版权声明：本文为CSDN博主「云等风来」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_33667439/article/details/78666979" target="_blank" rel="noopener">https://blog.csdn.net/qq_33667439/article/details/78666979</a></p><h2 id="3-接口的应用之一–接口回调"><a href="#3-接口的应用之一–接口回调" class="headerlink" title="3.接口的应用之一–接口回调"></a>3.接口的应用之一–接口回调</h2><h3 id="1-什么是接口回调呢"><a href="#1-什么是接口回调呢" class="headerlink" title="1.什么是接口回调呢"></a>1.什么是接口回调呢</h3><p>​    其实就是，A调用B，B再回去调用A的另一个方法，是不是很晕，晕就对了</p><p>打个比方：就是A去打车，问B多少钱，B说100块，然后A给了B 100元</p><p>再打个比方：小明问小花数学题，小花说我先学完java，学完后就打回给你，之后半小时，小花打电话回去给小明了</p></li></ul><h3 id="2-为什么要回调呢"><a href="#2-为什么要回调呢" class="headerlink" title="2.为什么要回调呢"></a>2.为什么要回调呢</h3><p>有人想说，直接A调用A的另一个方法就行了鸭，但是事情往往不是那么简单的，有一些事情必须要问别人，等待别人的回答，才能调用A的另一个方法，类比，总不能A自问自答吧</p><h3 id="3-简单的回调示例"><a href="#3-简单的回调示例" class="headerlink" title="3.简单的回调示例"></a>3.简单的回调示例</h3><p>实现功能，小明打电话给小花，小花接到电话后，完成数学作业后，再打电话给小明</p><p>//接口</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> net<span class="token punctuation">.</span>qiujuer<span class="token punctuation">.</span>web<span class="token punctuation">.</span>italker<span class="token punctuation">.</span>push<span class="token punctuation">.</span>service<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">CallBack</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">callBackToXiaoMing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>//小明</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">XiaoMing</span> <span class="token keyword">implements</span> <span class="token class-name">CallBack</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">askToXiaoHua</span><span class="token punctuation">(</span>XiaoHua xiaoHua<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"小明打电话给小花"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        xiaoHua<span class="token punctuation">.</span><span class="token function">answer</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这里为什么传入this,因为他实现了CallBack，本来是应该传入callBack的，但是因为当前类实现了CallBack，所以callBack有的东西当前的类也有，自然就可以传入this了</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">callBackToXiaoMing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"小明收到回电"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>//小花</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">XiaoHua</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">answer</span><span class="token punctuation">(</span>CallBack callBack<span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"小花接到了小明的电话"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment" spellcheck="true">//这里写的是小花花费了半个小时写作业</span>            <span class="token comment" spellcheck="true">//半小时后，打电话回去</span>        callBack<span class="token punctuation">.</span><span class="token function">callBackToXiaoMing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>main方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> net<span class="token punctuation">.</span>qiujuer<span class="token punctuation">.</span>web<span class="token punctuation">.</span>italker<span class="token punctuation">.</span>push<span class="token punctuation">.</span>service<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestCallBack</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        XiaoHua xiaoHua <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XiaoHua</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        XiaoMing xiaoMing <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XiaoMing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        xiaoMing<span class="token punctuation">.</span><span class="token function">askToXiaoHua</span><span class="token punctuation">(</span>xiaoHua<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="4-安卓中的接口回调是怎样的？"><a href="#4-安卓中的接口回调是怎样的？" class="headerlink" title="4.安卓中的接口回调是怎样的？"></a>4.安卓中的接口回调是怎样的？</h2><blockquote><p>其实接口回调经常见到</p></blockquote><h3 id="1-点击事件就是接口回调"><a href="#1-点击事件就是接口回调" class="headerlink" title="1.点击事件就是接口回调"></a>1.点击事件就是接口回调</h3><pre class=" language-java"><code class="language-java">mIvMe<span class="token punctuation">.</span><span class="token function">setOnClickListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">View<span class="token punctuation">.</span>OnClickListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//这里面写了点击后的处理，调用了点击事件的接口，注意：点击事件的接口的设计相对于上面所说的司机的角色</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onClick</span><span class="token punctuation">(</span>View v<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">startActivity</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Intent</span><span class="token punctuation">(</span>BaseActivity<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">,</span>MeActivity<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="2-接口回调怎么写？"><a href="#2-接口回调怎么写？" class="headerlink" title="2.接口回调怎么写？"></a>2.接口回调怎么写？</h3><h4 id="1-在需要传递数据的地方定义一个接口，例如可以直接接收点击事件的地方（RecyclerView的adapter）"><a href="#1-在需要传递数据的地方定义一个接口，例如可以直接接收点击事件的地方（RecyclerView的adapter）" class="headerlink" title="1.在需要传递数据的地方定义一个接口，例如可以直接接收点击事件的地方（RecyclerView的adapter）"></a>1.在需要传递数据的地方定义一个接口，例如可以直接接收点击事件的地方（RecyclerView的adapter）</h4><pre class=" language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">/** * 定义一个接口 */</span><span class="token keyword">public</span> <span class="token keyword">interface</span>  <span class="token class-name">onListener</span><span class="token punctuation">{</span>  <span class="token keyword">void</span> <span class="token function">OnListener</span><span class="token punctuation">(</span>String code<span class="token punctuation">,</span>String msg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="2-在需要传递数据的地方定义一个的接口类型的变量存储数据。"><a href="#2-在需要传递数据的地方定义一个的接口类型的变量存储数据。" class="headerlink" title="2.在需要传递数据的地方定义一个的接口类型的变量存储数据。"></a>2.在需要传递数据的地方<strong>定义一个的接口类型的变量存储数据。</strong></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** *定义一个变量储存数据 */</span><span class="token keyword">private</span> onListener listener<span class="token punctuation">;</span> </code></pre><h4 id="3-在需要传递数据的地方定义一个公共的方法，让外部去调用，并且传递接口类型的参数，给其定义的接口类型的数据初始化"><a href="#3-在需要传递数据的地方定义一个公共的方法，让外部去调用，并且传递接口类型的参数，给其定义的接口类型的数据初始化" class="headerlink" title="3.在需要传递数据的地方定义一个公共的方法，让外部去调用，并且传递接口类型的参数，给其定义的接口类型的数据初始化"></a>3.在需要传递数据的地方<strong>定义一个公共的方法，让外部去调用，并且传递接口类型的参数，给其定义的接口类型的数据初始化</strong></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** *提供公共的方法,并且初始化接口类型的数据 */</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setListener</span><span class="token punctuation">(</span> onListener listener<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>listener <span class="token operator">=</span> listener<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="4-在需要传递数据的地方，合适的位置调用接口里面的方法，传递数据。（比如点击事件的地方）"><a href="#4-在需要传递数据的地方，合适的位置调用接口里面的方法，传递数据。（比如点击事件的地方）" class="headerlink" title="4.在需要传递数据的地方，合适的位置调用接口里面的方法，传递数据。（比如点击事件的地方）"></a>4.在需要传递数据的地方，<strong>合适的位置调用接口里面的方法，传递数据。（比如点击事件的地方）</strong></h4><pre class=" language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">/** * 在合适的位置给其调用接口，给其赋值 */</span> @Override <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onClick</span><span class="token punctuation">(</span>View v<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>listener<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//这个判断不可少</span>          listener<span class="token punctuation">.</span><span class="token function">OnListener</span><span class="token punctuation">(</span>rtncode<span class="token punctuation">,</span>rtnmsg<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="5-在需要获取数据的地方，创建对象调方法。"><a href="#5-在需要获取数据的地方，创建对象调方法。" class="headerlink" title="5.在需要获取数据的地方，创建对象调方法。"></a>5.<strong>在需要获取数据的地方，创建对象调方法。</strong></h4><pre class=" language-java"><code class="language-java">allPersonAdapter<span class="token punctuation">.</span><span class="token function">setItemOnClickInterface</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">AllPersonAdapter<span class="token punctuation">.</span>ItemOnClickInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onClick</span><span class="token punctuation">(</span>View v<span class="token punctuation">,</span> <span class="token keyword">int</span> position<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//在这里获取数据进行处理</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 安卓基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安卓基础知识 </tag>
            
            <tag> java基础知识 </tag>
            
            <tag> 接口回调 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.11 树、森林与二叉树的转换</title>
      <link href="/2019/10/23/6.11-shu-sen-lin-yu-er-cha-shu-de-zhuan-huan/"/>
      <url>/2019/10/23/6.11-shu-sen-lin-yu-er-cha-shu-de-zhuan-huan/</url>
      
        <content type="html"><![CDATA[<h1 id="6-11-树、森林与二叉树的转换"><a href="#6-11-树、森林与二叉树的转换" class="headerlink" title="6.11 树、森林与二叉树的转换"></a>6.11 树、森林与二叉树的转换</h1><h2 id="6-11-1-树转换为二叉树"><a href="#6-11-1-树转换为二叉树" class="headerlink" title="6.11.1 树转换为二叉树"></a>6.11.1 树转换为<strong>二叉树</strong></h2><h3 id="1-步骤是什么？"><a href="#1-步骤是什么？" class="headerlink" title="1.步骤是什么？"></a>1.步骤是什么？</h3><ol><li>加线，在所有兄弟结点之间加一条连线；</li><li>去线，就是对树中的每个结点，只保留他与第一个孩子结点之间的连线，删除它与其它孩子结点之间的连线；</li><li>层次调整，是以树的根结点为轴心，将整棵树顺时针旋转一定角度，使之结构层次分明。</li></ol><p><img src="https://i.loli.net/2019/10/23/CxQZTmFYn3h8ELw.jpg" alt></p><h2 id="6-11-2-森林转换为二叉树"><a href="#6-11-2-森林转换为二叉树" class="headerlink" title="6.11.2 森林转换为二叉树"></a>6.11.2 森林<strong>转换为二叉树</strong></h2><h3 id="1-步骤是什么？-1"><a href="#1-步骤是什么？-1" class="headerlink" title="1.步骤是什么？"></a>1.步骤是什么？</h3><ol><li>先把<strong>每棵树转换为二叉树</strong>；</li><li>第一棵二叉树不动，从第二棵二叉树开始，依次<strong>把后一棵二叉树的根结点</strong>作为<strong>前一棵二叉树</strong>的<strong>根结点的右孩子</strong>结点，用线连接起来。当所有的二叉树连接起来后得到的二叉树就是由森林转换得到的二叉树</li></ol><p><img src="https://i.loli.net/2019/10/23/kDR29fTqIHF38Xl.jpg" alt></p><h2 id="6-11-3-二叉树转化为树"><a href="#6-11-3-二叉树转化为树" class="headerlink" title="6.11.3 二叉树转化为树"></a>6.11.3 二叉树转化为树</h2><h3 id="1-步骤是什么？-2"><a href="#1-步骤是什么？-2" class="headerlink" title="1.步骤是什么？"></a>1.步骤是什么？</h3><ol><li>若某结点的左孩子结点存在，将左孩子结点的右孩子结点、右孩子结点的右孩子结点……都作为该结点的孩子结点，将该结点与这些右孩子结点用线连接起来（反正是左孩子的n个右孩子结点）</li><li>去线，删除原二叉树中所有结点与其右孩子结点的连线；</li><li>层次调整</li></ol><p><img src="https://i.loli.net/2019/10/23/YGgTMPKELtbAxcm.jpg" alt></p><h2 id="6-11-4-二叉树转换为森林"><a href="#6-11-4-二叉树转换为森林" class="headerlink" title="6.11.4 二叉树转换为森林"></a>6.11.4 <strong>二叉树转换为森林</strong></h2><h3 id="1-步骤是什么？-3"><a href="#1-步骤是什么？-3" class="headerlink" title="1.步骤是什么？"></a>1.步骤是什么？</h3><ol><li><p>先把每个结点与右孩子结点的连线删除，得到分离的二叉树；（先分出每棵树）</p></li><li><p>把分离后的每棵二叉树转换为树；</p></li><li><p>整理</p><p><img src="https://i.loli.net/2019/10/23/WUjwXCGIJulRPb3.jpg" alt></p></li></ol><h2 id="6-11-5-树和森林的遍历"><a href="#6-11-5-树和森林的遍历" class="headerlink" title="6.11.5 树和森林的遍历"></a>6.11.5 树和森林的遍历</h2><h3 id="1-树的遍历方式有几种？"><a href="#1-树的遍历方式有几种？" class="headerlink" title="1.树的遍历方式有几种？"></a>1.树的遍历方式有几种？</h3><p><img src="https://i.loli.net/2019/10/23/YGgTMPKELtbAxcm.jpg" alt></p><h4 id="1-第一种，根优先遍历"><a href="#1-第一种，根优先遍历" class="headerlink" title="1.第一种，根优先遍历"></a>1.第一种，根优先遍历</h4><p>先根遍历树，就是<strong>先访问树的根节点，然后依次根遍历根的子树</strong>，拿上图举例，就是 <strong>ABCEFDGHI</strong></p><h4 id="2-第二种，后根遍历"><a href="#2-第二种，后根遍历" class="headerlink" title="2.第二种，后根遍历"></a>2.第二种，后根遍历</h4><p><strong>先依次后根遍历每棵子树</strong>，然后<strong>再访问根结点</strong>，拿上图举例，就是 <strong>ECFBDHIGA</strong></p><h3 id="2-森林的遍历有几种方式？"><a href="#2-森林的遍历有几种方式？" class="headerlink" title="2.森林的遍历有几种方式？"></a>2.森林的遍历有几种方式？</h3><p><img src="https://i.loli.net/2019/10/23/WUjwXCGIJulRPb3.jpg" alt></p><h4 id="1-前序遍历："><a href="#1-前序遍历：" class="headerlink" title="1.前序遍历："></a>1.前序遍历：</h4><p>其实就是先访问森林中第一棵树的根节点，然后依次遍历根的子树，然后再找下一棵树的根，再重复上述操作</p><p>上图的就是，ABCDEFGHJI</p><h4 id="2-后序遍历："><a href="#2-后序遍历：" class="headerlink" title="2.后序遍历："></a>2.后序遍历：</h4><p>其实就是以后根方式依次遍历每一棵树</p><p>上图的就是，BCDAFEJHIG</p><h3 id="总结前面的，其实我们可以知道，森林的前序遍历和二叉树的前序遍历结果相同，森林的后序遍历和二叉树的中序遍历结果相同"><a href="#总结前面的，其实我们可以知道，森林的前序遍历和二叉树的前序遍历结果相同，森林的后序遍历和二叉树的中序遍历结果相同" class="headerlink" title="总结前面的，其实我们可以知道，森林的前序遍历和二叉树的前序遍历结果相同，森林的后序遍历和二叉树的中序遍历结果相同"></a>总结前面的，其实我们可以知道，森林的前序遍历和二叉树的前序遍历结果相同，森林的后序遍历和二叉树的中序遍历结果相同</h3>]]></content>
      
      
      <categories>
          
          <category> 大话数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大话数据结构 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>广义表简析</title>
      <link href="/2019/10/23/guang-yi-biao-jian-xi/"/>
      <url>/2019/10/23/guang-yi-biao-jian-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="广义表简析"><a href="#广义表简析" class="headerlink" title="广义表简析"></a>广义表简析</h1><blockquote><p>什么是广义表呢？你知道文件系统吗</p></blockquote><h2 id="1-什么是广义表呢？"><a href="#1-什么是广义表呢？" class="headerlink" title="1.什么是广义表呢？"></a>1.什么是广义表呢？</h2><p>其实就是一个可以表中有表的，允许表的嵌套的结构</p><p>例如:文件系统，文件夹下面可能是文件夹，也可能是文件，这就是广义表</p><h2 id="2-广义表有什么属性呢？"><a href="#2-广义表有什么属性呢？" class="headerlink" title="2.广义表有什么属性呢？"></a>2.广义表有什么属性呢？</h2><ul><li><p>表头，表尾</p><p>表头是第一个元素，表尾是除表头以外的元素</p></li><li><p>长度</p><p>广义表的元素个数</p></li><li><p>深度</p><p>广义表的嵌套层数，需要注意，<strong>空表</strong>的深度是1，<strong>原子</strong>的深度是0</p></li></ul><h2 id="3-存储结构"><a href="#3-存储结构" class="headerlink" title="3.存储结构"></a>3.存储结构</h2><h3 id="1-是链式还是顺序表式"><a href="#1-是链式还是顺序表式" class="headerlink" title="1.是链式还是顺序表式"></a>1.是链式还是顺序表式</h3><p>链式，便于存储空间的扩容</p><h3 id="2-结点的分类："><a href="#2-结点的分类：" class="headerlink" title="2.结点的分类："></a>2.结点的分类：</h3><ol><li><p>原子结点（ATOM==0）</p></li><li><p>表结点（LIST==1）</p><p>表结点用来表示一个广义表</p></li></ol><p><img src="https://i.loli.net/2019/10/23/Z1dzhrqCw6ypnxO.jpg" alt></p><h2 id="4-广义表的分解方式"><a href="#4-广义表的分解方式" class="headerlink" title="4.广义表的分解方式"></a>4.广义表的分解方式</h2><h3 id="1-分解为表头和表尾，2个子集，分别递归求解，直至空表或者原子出现"><a href="#1-分解为表头和表尾，2个子集，分别递归求解，直至空表或者原子出现" class="headerlink" title="1.分解为表头和表尾，2个子集，分别递归求解，直至空表或者原子出现"></a>1.分解为表头和表尾，2个子集，分别递归求解，直至空表或者原子出现</h3><p><img src="https://i.loli.net/2019/10/23/Bhi4Sp8ZlJLow5q.jpg" alt></p><h3 id="2-每个元素依次分解"><a href="#2-每个元素依次分解" class="headerlink" title="2.每个元素依次分解"></a>2.每个元素依次分解</h3><p><img src="https://i.loli.net/2019/10/23/j3rRJdYagkwvIGx.jpg" alt></p><p>由此可见，方式2比方式1分解层数少</p><h2 id="5-广义表常用操作实现"><a href="#5-广义表常用操作实现" class="headerlink" title="5.广义表常用操作实现"></a>5.广义表常用操作实现</h2><h3 id="1-求深度的算法"><a href="#1-求深度的算法" class="headerlink" title="1.求深度的算法"></a>1.求深度的算法</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">GListDepth</span><span class="token punctuation">(</span>GList L<span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">int</span> h1<span class="token punctuation">,</span>h2<span class="token punctuation">;</span>     <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token operator">==</span>L<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//空表</span>     <span class="token keyword">if</span><span class="token punctuation">(</span>ATOM<span class="token operator">==</span>L<span class="token operator">-></span>tag<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//原子</span>     h1<span class="token operator">=</span><span class="token function">GListDepth</span><span class="token punctuation">(</span>L<span class="token operator">-></span>un<span class="token punctuation">.</span>ptr<span class="token punctuation">.</span>hp<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//表头深度+1</span>     h2<span class="token operator">=</span><span class="token function">GListDepth</span><span class="token punctuation">(</span>L<span class="token operator">-></span>un<span class="token punctuation">.</span>ptr<span class="token punctuation">.</span>tp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//表尾的深度和原表相同</span>     <span class="token keyword">return</span> h1<span class="token operator">>=</span>h2<span class="token operator">?</span> h1<span class="token punctuation">:</span>h2<span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><h3 id="2-在表尾添加元素"><a href="#2-在表尾添加元素" class="headerlink" title="2.在表尾添加元素"></a>2.在表尾添加元素</h3><pre class=" language-c"><code class="language-c">bool <span class="token function">Append</span><span class="token punctuation">(</span>GList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span>GLNode <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//在广义表末尾添加新的表结点，将参数p赋予表头指针hp</span>    GLNode <span class="token operator">*</span>pp<span class="token punctuation">;</span>    GList tail<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//新建表尾结点</span>    tail<span class="token operator">=</span><span class="token punctuation">(</span>GList<span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>GLNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token operator">==</span>tail<span class="token punctuation">)</span> <span class="token keyword">return</span> OVERFLOW<span class="token punctuation">;</span>    tail<span class="token operator">-></span>tag<span class="token operator">=</span>LIST<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//添加数据</span>    tail<span class="token operator">-></span>un<span class="token punctuation">.</span>ptr<span class="token punctuation">.</span>hp<span class="token operator">=</span>p<span class="token punctuation">;</span>    tail<span class="token operator">-></span>un<span class="token punctuation">.</span>ptr<span class="token punctuation">.</span>tp<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token operator">==</span>L<span class="token punctuation">)</span> L<span class="token operator">=</span>tail<span class="token punctuation">;</span>    <span class="token keyword">else</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>pp<span class="token operator">=</span>L<span class="token punctuation">;</span>pp<span class="token operator">-></span>un<span class="token punctuation">.</span>ptr<span class="token punctuation">.</span>tp<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>pp<span class="token operator">=</span>pp<span class="token operator">-></span>un<span class="token punctuation">.</span>ptr<span class="token punctuation">.</span>tp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//定位到最后一个结点</span>        pp<span class="token operator">-></span>un<span class="token punctuation">.</span>ptr<span class="token punctuation">.</span>tp<span class="token operator">=</span>tail<span class="token punctuation">;</span>     <span class="token punctuation">}</span>    <span class="token keyword">return</span> OK<span class="token punctuation">;</span><span class="token punctuation">}</span> </code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 广义表 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.9 二叉树的建立</title>
      <link href="/2019/10/23/6.9-er-cha-shu-de-jian-li/"/>
      <url>/2019/10/23/6.9-er-cha-shu-de-jian-li/</url>
      
        <content type="html"><![CDATA[<h1 id="6-9-二叉树的建立"><a href="#6-9-二叉树的建立" class="headerlink" title="6.9 二叉树的建立"></a>6.9 二叉树的建立</h1><h2 id="1-什么是拓展二叉树"><a href="#1-什么是拓展二叉树" class="headerlink" title="1.什么是拓展二叉树"></a>1.什么是拓展二叉树</h2><p>简单说，就是将叶子结点也补上空指针，使其形成类似于完全二叉树的样子</p><p><img src="https://i.loli.net/2019/10/15/kS9qYKHmROis4gh.jpg" alt></p><h2 id="2-怎么生成一个二叉树呢？"><a href="#2-怎么生成一个二叉树呢？" class="headerlink" title="2.怎么生成一个二叉树呢？"></a>2.怎么生成一个二叉树呢？</h2><p>我们把刚才<strong>前序</strong>遍历序列<strong>AB#D##C##</strong>用键盘挨个输入。实现如下算法：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//根左右</span><span class="token keyword">void</span>  <span class="token function">CreateBiTree</span><span class="token punctuation">(</span>BiTree   <span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token punctuation">{</span>     TElemType   ch<span class="token punctuation">;</span>     <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span><span class="token punctuation">(</span>ch<span class="token operator">==</span><span class="token string">'#'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token operator">*</span>T<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>               <span class="token operator">*</span>T<span class="token operator">=</span><span class="token punctuation">(</span>SiTree<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>SiTNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//生成根结点</span>                 <span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token operator">-></span>data <span class="token operator">=</span> ch<span class="token punctuation">;</span>               <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">*</span>T<span class="token punctuation">)</span>                <span class="token function">exit</span><span class="token punctuation">(</span>OVERFLOW<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">CreateBiTree</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//左子树</span>                <span class="token function">CreateBiTree</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//右子树</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>其实生成二叉树的方法也是用到了递归的思想</p>]]></content>
      
      
      <categories>
          
          <category> 大话数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大话数据结构 </tag>
            
            <tag> 树 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.8 遍历二叉树</title>
      <link href="/2019/10/23/6.8-bian-li-er-cha-shu/"/>
      <url>/2019/10/23/6.8-bian-li-er-cha-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="6-8-遍历二叉树"><a href="#6-8-遍历二叉树" class="headerlink" title="6.8 遍历二叉树"></a>6.8 遍历二叉树</h1><h2 id="6-8-1-原理"><a href="#6-8-1-原理" class="headerlink" title="6.8.1 原理"></a>6.8.1 原理</h2><p>是指从根节点出发，按照<strong>某种次序依次</strong>访问二叉树中的所有节点，使得每个节点被访问一次且<strong>仅被访问一次</strong>。</p><p>重点和难点是<strong>次序</strong></p><h2 id="6-8-2-二叉树遍历方法"><a href="#6-8-2-二叉树遍历方法" class="headerlink" title="6.8.2  二叉树遍历方法"></a>6.8.2  二叉树遍历方法</h2><h3 id="1-前序遍历"><a href="#1-前序遍历" class="headerlink" title="1.前序遍历"></a>1.前序遍历</h3><p><strong>根左右</strong></p><p>简单说就是：从根节点开始，<strong>先左边，后右边,从高到低</strong></p><p>比如说下面的次序是：ABDGHCEIF</p><p><img src="https://s2.ax1x.com/2019/10/15/KPQJrn.jpg" alt="KPQJrn.jpg"></p><p>代码：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">PreOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">/*先序遍历: 根-左-右*/</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span>T<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//显示结点数据</span>        <span class="token function">PreOrder</span><span class="token punctuation">(</span>T<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//先遍历左子树</span>        <span class="token function">PreOrder</span><span class="token punctuation">(</span>T<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//再遍历右子树</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="2-中序遍历：左根右"><a href="#2-中序遍历：左根右" class="headerlink" title="2.中序遍历：左根右"></a>2.中序遍历：左根右</h3><p>简单说就是，从下面开始，<strong>左根右</strong></p><p><img src="https://s2.ax1x.com/2019/10/15/KPltQH.jpg" alt="KPltQH.jpg"></p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">InOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token comment" spellcheck="true">/*中序遍历：左-根-右*/</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">InOrder</span><span class="token punctuation">(</span>T<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//先遍历左子树</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span>T<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//显示结点数据</span>        <span class="token function">InOrder</span><span class="token punctuation">(</span>T<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//再遍历右子树</span>    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="3-后序遍历：左右根"><a href="#3-后序遍历：左右根" class="headerlink" title="3.后序遍历：左右根"></a>3.后序遍历：左右根</h3><p>从下到上，左右根</p><p><img src="https://s2.ax1x.com/2019/10/15/KPlb6J.jpg" alt="KPlb6J.jpg"></p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">PostOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token comment" spellcheck="true">/*后序遍历：左-右-根*/</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">PostOrder</span><span class="token punctuation">(</span>T<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//先遍历左子树</span>        <span class="token function">PostOrder</span><span class="token punctuation">(</span>T<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//再遍历右子树</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span>T<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//显示结点数据</span>    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="4-层序遍历"><a href="#4-层序遍历" class="headerlink" title="4.层序遍历"></a>4.层序遍历</h3><p>从根节点出发，依次访问左右孩子结点，再从左右孩子出发，依次它们的孩子结点，直到节点访问完毕</p><p>简而言之：从上到下，一层一层</p><p><img src="https://i.loli.net/2019/10/15/gKQ42qOy6WSrwt3.jpg" alt></p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/*层序遍历 思路：按从左至右的顺序来逐层访问每个节点，层序遍历的过程需要队列*/</span><span class="token keyword">void</span> <span class="token function">LevelOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>    BiTree p <span class="token operator">=</span> T<span class="token punctuation">;</span>    queue<span class="token operator">&lt;</span>BiTree<span class="token operator">></span> queue<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">/*队列*/</span>    queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">/*根节点入队*/</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">/*队列不空循环 */</span>    <span class="token punctuation">{</span>        p <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">/*对头元素出队*/</span>        <span class="token comment" spellcheck="true">//printf("%c ",p->data); </span><span class="token comment" spellcheck="true">/*访问p指向的结点*/</span>        cout <span class="token operator">&lt;&lt;</span> p<span class="token operator">-></span>data <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>        queue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">/*退出队列*/</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>lchild <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">/*左子树不空，将左子树入队*/</span>            queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>p<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>rchild <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">/*右子树不空，将右子树入队*/</span>            queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>p<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="6-8-6-推导遍历结果"><a href="#6-8-6-推导遍历结果" class="headerlink" title="6.8.6 推导遍历结果"></a>6.8.6 推导遍历结果</h2><h3 id="1-已知前序遍历序列和中序遍历序列，可以唯一确定二叉树吗？"><a href="#1-已知前序遍历序列和中序遍历序列，可以唯一确定二叉树吗？" class="headerlink" title="1.已知前序遍历序列和中序遍历序列，可以唯一确定二叉树吗？"></a>1.已知前序遍历序列和中序遍历序列，可以唯一确定二叉树吗？</h3><p>前序的话，可以一眼看出根节点是第一个</p><h3 id="2-已知后序和中序，可以唯一确定二叉树吗"><a href="#2-已知后序和中序，可以唯一确定二叉树吗" class="headerlink" title="2.已知后序和中序，可以唯一确定二叉树吗?"></a>2.已知后序和中序，可以唯一确定二叉树吗?</h3><p>后序的话，可以一眼看出根节点是最后一个</p><h3 id="结论：中序是一定要有的，才能确定二叉树"><a href="#结论：中序是一定要有的，才能确定二叉树" class="headerlink" title="结论：中序是一定要有的，才能确定二叉树"></a>结论：中序是一定要有的，才能确定二叉树</h3><h2 id="本节重点："><a href="#本节重点：" class="headerlink" title="本节重点："></a>本节重点：</h2><h3 id="记住三字口诀"><a href="#记住三字口诀" class="headerlink" title="记住三字口诀"></a>记住三字口诀</h3><h3 id="根左右"><a href="#根左右" class="headerlink" title="根左右"></a>根左右</h3><h3 id="左根右"><a href="#左根右" class="headerlink" title="左根右"></a>左根右</h3><h3 id="左右根"><a href="#左右根" class="headerlink" title="左右根"></a>左右根</h3>]]></content>
      
      
      <categories>
          
          <category> 大话数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大话数据结构 </tag>
            
            <tag> 树 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.7 二叉树的存储结构</title>
      <link href="/2019/10/23/6.7-er-cha-shu-de-cun-chu-jie-gou/"/>
      <url>/2019/10/23/6.7-er-cha-shu-de-cun-chu-jie-gou/</url>
      
        <content type="html"><![CDATA[<h1 id="6-7-二叉树的存储结构"><a href="#6-7-二叉树的存储结构" class="headerlink" title="6.7 二叉树的存储结构"></a>6.7 二叉树的存储结构</h1><h2 id="1-顺序存储"><a href="#1-顺序存储" class="headerlink" title="1.顺序存储"></a>1.顺序存储</h2><p>一般只有用于完全二叉树（由于普通的二叉树，例如左斜树，造成存储空间的浪费）</p><h2 id="2-二叉链表"><a href="#2-二叉链表" class="headerlink" title="2.二叉链表"></a>2.二叉链表</h2><p>1个数据域，2个指针域，</p><p><img src="https://s2.ax1x.com/2019/10/15/KPiCQO.png" alt="KPiCQO.png"></p>]]></content>
      
      
      <categories>
          
          <category> 大话数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大话数据结构 </tag>
            
            <tag> 树 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.6 二叉树的性质</title>
      <link href="/2019/10/23/6.6-er-cha-shu-de-xing-zhi/"/>
      <url>/2019/10/23/6.6-er-cha-shu-de-xing-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="6-6-二叉树的性质"><a href="#6-6-二叉树的性质" class="headerlink" title="6.6 二叉树的性质"></a>6.6 二叉树的性质</h1><h2 id="1-一层最多结点数性质："><a href="#1-一层最多结点数性质：" class="headerlink" title="1.一层最多结点数性质："></a>1.一层最多结点数性质：</h2><p>最多2的（层数-1）次方个结点</p><h2 id="2-已知深度，求最大结点数的性质"><a href="#2-已知深度，求最大结点数的性质" class="headerlink" title="2.已知深度，求最大结点数的性质"></a>2.已知深度，求最大结点数的性质</h2><p><img src="https://s2.ax1x.com/2019/10/15/KP9OcF.png" alt="KP9OcF.png"></p><p>与上面不同，上面是次方里面-1，这里是次方外面-1</p><h2 id="3-终端结点数和度数为2的结点数的关系"><a href="#3-终端结点数和度数为2的结点数的关系" class="headerlink" title="3.终端结点数和度数为2的结点数的关系"></a>3.终端结点数和度数为2的结点数的关系</h2><p>叶子结点数=度数为2的结点数+1</p><h2 id="4-已知结点数，求深度"><a href="#4-已知结点数，求深度" class="headerlink" title="4.已知结点数，求深度"></a>4.已知结点数，求深度</h2><p><img src="https://s2.ax1x.com/2019/10/15/KPC4gO.png" alt="KPC4gO.png"></p><h2 id="5-根据结点总数和编号判断结点类型"><a href="#5-根据结点总数和编号判断结点类型" class="headerlink" title="5.根据结点总数和编号判断结点类型"></a>5.根据结点总数和编号判断结点类型</h2><p>如果对一棵有n个结点的完全二叉树的结点按层序编号，对任一结点 i 有</p><ul><li>若i=1,则i是根；如果i&gt;1,则双亲是结点i/2（向下取整）</li><li>如果2i&gt;n,则结点i是叶子结点；否则左孩子是2i</li><li>如果2i+1&gt;n,则无右孩子；否则右孩子是2i+1；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 大话数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大话数据结构 </tag>
            
            <tag> 树 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.5 二叉树的定义</title>
      <link href="/2019/10/23/6.5-er-cha-shu-de-ding-yi/"/>
      <url>/2019/10/23/6.5-er-cha-shu-de-ding-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="6-5-二叉树的定义"><a href="#6-5-二叉树的定义" class="headerlink" title="6.5 二叉树的定义"></a>6.5 二叉树的定义</h1><blockquote><p>上一节6.4 我们已经探讨了一种树的表示方法，孩子兄弟表示法，其实这就和我们这节要探讨的二叉树很有相似性</p></blockquote><h2 id="总起：二叉树是什么？"><a href="#总起：二叉树是什么？" class="headerlink" title="总起：二叉树是什么？"></a>总起：二叉树是什么？</h2><p>二叉树其实就是每个结点最多只有2个分叉的树</p><p>百度上的概念是：</p><p><img src="https://i.loli.net/2019/10/15/jzasn8x1cVgw47b.jpg" alt></p><p>例如：</p><p><img src="https://i.loli.net/2019/10/15/wAaNCqcfJVSPItL.jpg" alt></p><h2 id="6-5-1-二叉树的特点"><a href="#6-5-1-二叉树的特点" class="headerlink" title="6.5.1 二叉树的特点"></a>6.5.1 二叉树的特点</h2><h3 id="1-二叉树的特点有什么呢？"><a href="#1-二叉树的特点有什么呢？" class="headerlink" title="1.二叉树的特点有什么呢？"></a>1.二叉树的特点有什么呢？</h3><ul><li>每个结点最多2个子树</li><li>左子树和右子树是<strong>有顺序的</strong></li><li>即使只有<strong>1个</strong>结点，也要<strong>区分是左子树还是右子树</strong></li></ul><h3 id="2-二叉树有几种形态呢"><a href="#2-二叉树有几种形态呢" class="headerlink" title="2.二叉树有几种形态呢"></a>2.二叉树有几种形态呢</h3><ul><li>空二叉树</li><li>只有根节点</li><li>只有左子树</li><li>只有右子树</li><li>既有左子树，又有右子树</li></ul><h3 id="3-如果是1棵树只有3个结点的话，有几种形态呢？"><a href="#3-如果是1棵树只有3个结点的话，有几种形态呢？" class="headerlink" title="3.如果是1棵树只有3个结点的话，有几种形态呢？"></a>3.如果是1棵树只有3个结点的话，有几种形态呢？</h3><p>5种</p><p><img src="https://s2.ax1x.com/2019/10/15/KCTZ0e.png" alt="KCTZ0e.png"></p><h2 id="6-5-2-特殊二叉树"><a href="#6-5-2-特殊二叉树" class="headerlink" title="6.5.2  特殊二叉树"></a>6.5.2  特殊二叉树</h2><h3 id="1-什么是斜树"><a href="#1-什么是斜树" class="headerlink" title="1.什么是斜树"></a>1.什么是斜树</h3><p><img src="https://s2.ax1x.com/2019/10/15/KCTonO.png" alt="KCTonO.png"></p><p>所有结点都只有左子树的二叉树叫左斜树</p><p>所有结点都只有右子树的二叉树叫右斜树</p><p>这两者统称为斜树。</p><p>线性表结构可以理解为是树的一种极其特殊的表现形式</p><h3 id="2-满二叉树"><a href="#2-满二叉树" class="headerlink" title="2.满二叉树"></a>2.满二叉树</h3><p>定义：一棵二叉树中，所有分支结点都存在左右子树，并且所有叶子都在同一层</p><p>类比完美的学生，什么都会</p><p><img src="https://s2.ax1x.com/2019/10/15/KC7ACn.png" alt="KC7ACn.png"></p><h3 id="3-完全二叉树"><a href="#3-完全二叉树" class="headerlink" title="3.完全二叉树"></a>3.完全二叉树</h3><p>定义：对一棵具有n个结点的二叉树按层序编号，如果编号i(1&lt;=i&lt;=n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中<strong>位置完全相同</strong>，则此二叉树为完全二叉树</p><p>类比：追求完美的勤奋的学生，就是他的轨迹都模仿着完美的学生，不能突破常规，要什么都学精了再前进</p><p><img src="https://s2.ax1x.com/2019/10/15/KC7tKK.png" alt="KC7tKK.png"></p><h4 id="非完全二叉树示例："><a href="#非完全二叉树示例：" class="headerlink" title="非完全二叉树示例："></a>非完全二叉树示例：</h4><p><img src="https://s2.ax1x.com/2019/10/15/KC7o2q.png" alt="KC7o2q.png"></p>]]></content>
      
      
      <categories>
          
          <category> 大话数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大话数据结构 </tag>
            
            <tag> 树 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.8 归并排序</title>
      <link href="/2019/10/22/9.8-gui-bing-pai-xu/"/>
      <url>/2019/10/22/9.8-gui-bing-pai-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="9-8-归并排序"><a href="#9-8-归并排序" class="headerlink" title="9.8 归并排序"></a>9.8 归并排序</h1><blockquote><p>什么是归并排序呢？</p></blockquote><p><img src="https://i.loli.net/2019/10/22/GTd3q5UmOg6rBoS.jpg" alt></p><h2 id="9-8-1-归并排序算法"><a href="#9-8-1-归并排序算法" class="headerlink" title="9.8.1 归并排序算法"></a>9.8.1 归并排序算法</h2><h3 id="1-什么是归并排序（2路归并）？"><a href="#1-什么是归并排序（2路归并）？" class="headerlink" title="1.什么是归并排序（2路归并）？"></a>1.什么是归并排序（2路归并）？</h3><p>其实简单说就是，把一个数字序列，按数字一个一个分开来，然后相邻的数字两两归并，如上图</p><h3 id="2-归并排序代码是怎样的？"><a href="#2-归并排序代码是怎样的？" class="headerlink" title="2.归并排序代码是怎样的？"></a>2.归并排序代码是怎样的？</h3><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 对顺序表L作归并排序 */</span><span class="token keyword">void</span> <span class="token function">MergeSort</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token function">MSort</span><span class="token punctuation">(</span>L<span class="token operator">-></span>r<span class="token punctuation">,</span>L<span class="token operator">-></span>r<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>L<span class="token operator">-></span>length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 将SR[s..t]归并排序为TR1[s..t] */</span><span class="token keyword">void</span> <span class="token function">MSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> SR<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> TR1<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> t<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">int</span> m<span class="token punctuation">;</span> <span class="token keyword">int</span> TR2<span class="token punctuation">[</span>MAXSIZE<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token operator">==</span>t<span class="token punctuation">)</span>  TR1<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token operator">=</span>SR<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//当细分为1个数字的时候，递归结束</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      m<span class="token operator">=</span><span class="token punctuation">(</span>s<span class="token operator">+</span>t<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 将SR[s..t]平分为SR[s..m]和SR[m+1..t] */</span>      <span class="token function">MSort</span><span class="token punctuation">(</span>SR<span class="token punctuation">,</span>TR2<span class="token punctuation">,</span>s<span class="token punctuation">,</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 递归地将SR[s..m]归并为有序的TR2[s..m] */</span> <span class="token comment" spellcheck="true">//将前半部分归并</span>      <span class="token function">MSort</span><span class="token punctuation">(</span>SR<span class="token punctuation">,</span>TR2<span class="token punctuation">,</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 递归地将SR[m+1..t]归并为有序TR2[m+1..t] */</span> <span class="token comment" spellcheck="true">//将后半部分归并</span>      <span class="token function">Merge</span><span class="token punctuation">(</span>TR2<span class="token punctuation">,</span>TR1<span class="token punctuation">,</span>s<span class="token punctuation">,</span>m<span class="token punctuation">,</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 将TR2[s..m]和TR2[m+1..t]归并到TR1[s..t] */</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>其实思路就是，先把一串数字，分为单个数字，然后对相邻的单个数字进行递归排序</p><p>总的数字是：</p><p><img src="https://i.loli.net/2019/10/22/UWvQHiG8otAkujL.jpg" alt></p><p>现在我们来分析重点代码：</p><pre class=" language-c"><code class="language-c"> <span class="token function">MSort</span><span class="token punctuation">(</span>SR<span class="token punctuation">,</span>TR2<span class="token punctuation">,</span>s<span class="token punctuation">,</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//其实是将前半部分分开</span><span class="token comment" spellcheck="true">//每次递归返回后都会执行当前递归函数的Merge(TR2,TR1,s,m,t);，将TR2归并到TR1中。如图9-8-4的右图。最终使得当前序列有序。</span></code></pre><p><img src="https://i.loli.net/2019/10/22/c9jqwiXvhbLAx7P.jpg" alt></p><p>同理：</p><pre class=" language-c"><code class="language-c">  <span class="token function">MSort</span><span class="token punctuation">(</span>SR<span class="token punctuation">,</span>TR2<span class="token punctuation">,</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 递归地将SR[m+1..t]归并为有序TR2[m+1..t] */</span> <span class="token comment" spellcheck="true">//将后半部分归并</span></code></pre><p><img src="https://i.loli.net/2019/10/22/zPkSiVbcUmN8v5t.jpg" alt></p><p>其实两部分结合，总体就是：</p><p><img src="https://i.loli.net/2019/10/22/wKd1bVck9NCYJF6.jpg" alt></p><h3 id="3-Merge函数的代码是怎样的？"><a href="#3-Merge函数的代码是怎样的？" class="headerlink" title="3.Merge函数的代码是怎样的？"></a>3.Merge函数的代码是怎样的？</h3><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 将有序的SR[i..m]和SR[m+1..n]归并为有序的TR[i..n] */</span><span class="token keyword">void</span> <span class="token function">Merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> SR<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> TR<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span><span class="token keyword">int</span> m<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">int</span> j<span class="token punctuation">,</span>k<span class="token punctuation">,</span>l<span class="token punctuation">;</span> <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>k<span class="token operator">=</span>i<span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>m <span class="token operator">&amp;&amp;</span> j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">/* 将SR中记录由小到大归并入TR */</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>SR<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>SR<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>   TR<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span>SR<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">else</span>   TR<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span>SR<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//如果前半部分有剩余</span> <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>m<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">for</span><span class="token punctuation">(</span>l<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>l<span class="token operator">&lt;=</span>m<span class="token operator">-</span>i<span class="token punctuation">;</span>l<span class="token operator">++</span><span class="token punctuation">)</span>   TR<span class="token punctuation">[</span>k<span class="token operator">+</span>l<span class="token punctuation">]</span><span class="token operator">=</span>SR<span class="token punctuation">[</span>i<span class="token operator">+</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 将剩余的SR[i..m]复制到TR */</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//如果后半部分有剩余</span> <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">for</span><span class="token punctuation">(</span>l<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>l<span class="token operator">&lt;=</span>n<span class="token operator">-</span>j<span class="token punctuation">;</span>l<span class="token operator">++</span><span class="token punctuation">)</span>   TR<span class="token punctuation">[</span>k<span class="token operator">+</span>l<span class="token punctuation">]</span><span class="token operator">=</span>SR<span class="token punctuation">[</span>j<span class="token operator">+</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 将剩余的SR[j..n]复制到TR */</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>代码不是很难：直接看图可以明白</p><p><img src="https://i.loli.net/2019/10/22/K2WvDbgVCQado4m.jpg" alt></p><p><img src="https://i.loli.net/2019/10/22/J7X964hPg1nDKur.jpg" alt></p><p><img src="https://i.loli.net/2019/10/22/XwObf2jZY97xJ3S.jpg" alt></p><p><img src="https://i.loli.net/2019/10/22/BLufKq3vN69igQ7.jpg" alt></p><h2 id="9-8-2-归并排序的复杂度是多少？"><a href="#9-8-2-归并排序的复杂度是多少？" class="headerlink" title="9.8.2 归并排序的复杂度是多少？"></a>9.8.2 归并排序的复杂度是多少？</h2><ul><li>时间复杂度是：O（nlogn）</li><li>空间复杂度是：O（n+logn）</li></ul><h2 id="9-8-3-非递归实现归并排序"><a href="#9-8-3-非递归实现归并排序" class="headerlink" title="9.8.3  非递归实现归并排序"></a>9.8.3  非递归实现归并排序</h2><h3 id="1-思想是什么？"><a href="#1-思想是什么？" class="headerlink" title="1.思想是什么？"></a>1.思想是什么？</h3><p>其实就是用迭代的方式，代替递归的方式，思想主要是，用迭代的方式找单个数字，而不是用递归分为单个数字再返回</p><h3 id="2-代码是怎样的？"><a href="#2-代码是怎样的？" class="headerlink" title="2.代码是怎样的？"></a>2.代码是怎样的？</h3><p>注意：这里的TR的临时空间，相当于中转站的作用，最后的排序的结构还是要放在原来的空间中</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 对顺序表L作归并非递归排序 */</span><span class="token keyword">void</span> <span class="token function">MergeSort2</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">int</span><span class="token operator">*</span> TR<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>L<span class="token operator">-></span>length <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 申请额外空间 */</span> <span class="token keyword">int</span> k<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token keyword">while</span><span class="token punctuation">(</span>k<span class="token operator">&lt;</span>L<span class="token operator">-></span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">MergePass</span><span class="token punctuation">(</span>L<span class="token operator">-></span>r<span class="token punctuation">,</span>TR<span class="token punctuation">,</span>k<span class="token punctuation">,</span>L<span class="token operator">-></span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//先归并放到TR中</span>  k<span class="token operator">=</span><span class="token number">2</span><span class="token operator">*</span>k<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 子序列长度加倍 */</span>  <span class="token function">MergePass</span><span class="token punctuation">(</span>TR<span class="token punctuation">,</span>L<span class="token operator">-></span>r<span class="token punctuation">,</span>k<span class="token punctuation">,</span>L<span class="token operator">-></span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//再归并放回原来的空间</span>  k<span class="token operator">=</span><span class="token number">2</span><span class="token operator">*</span>k<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 子序列长度加倍 */</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>MergePass的代码：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 将SR[]中相邻长度为s的子序列两两归并到TR[] */</span><span class="token keyword">void</span> <span class="token function">MergePass</span><span class="token punctuation">(</span><span class="token keyword">int</span> SR<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> TR<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> s<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token keyword">int</span> j<span class="token punctuation">;</span> <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> n<span class="token number">-2</span><span class="token operator">*</span>s<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>   <span class="token function">Merge</span><span class="token punctuation">(</span>SR<span class="token punctuation">,</span>TR<span class="token punctuation">,</span>i<span class="token punctuation">,</span>i<span class="token operator">+</span>s<span class="token number">-1</span><span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token operator">*</span>s<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 两两归并 */</span>  i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token operator">*</span>s<span class="token punctuation">;</span>         <span class="token punctuation">}</span> <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>n<span class="token operator">-</span>s<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>       <span class="token comment" spellcheck="true">/* 归并最后两个序列 */</span>  <span class="token comment" spellcheck="true">//最后一步</span>  <span class="token function">Merge</span><span class="token punctuation">(</span>SR<span class="token punctuation">,</span>TR<span class="token punctuation">,</span>i<span class="token punctuation">,</span>i<span class="token operator">+</span>s<span class="token number">-1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//将单个的数字归并进序列</span> <span class="token keyword">else</span>   <span class="token comment" spellcheck="true">/* 若最后只剩下单个子序列 */</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span>i<span class="token punctuation">;</span>j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>   TR<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> SR<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将单个的数字放在最后</span><span class="token punctuation">}</span></code></pre><p>一轮MergePass，这里的20是直接排在队尾的</p><p><img src="https://i.loli.net/2019/10/22/ZHJCEt9rpnl7iXY.jpg" alt></p><p><img src="https://i.loli.net/2019/10/22/RZQGTjJLnkhAVHt.jpg" alt></p><p>二轮MergePass，这里的20也是直接排在队尾的</p><p><img src="https://i.loli.net/2019/10/22/X4Dqeuih6ycnAN7.jpg" alt></p><p>三轮MergePass</p><p>这里的20是按顺序放入的</p><h3 id="3-相对递归的方式有什么优点呢？"><a href="#3-相对递归的方式有什么优点呢？" class="headerlink" title="3.相对递归的方式有什么优点呢？"></a>3.相对递归的方式有什么优点呢？</h3><ul><li>时间复杂度提升了</li><li>空间复杂度为O（n）,递归的空间复杂度是O（n+logn）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 大话数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大话数据结构 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式简析</title>
      <link href="/2019/10/20/2019-10-20-dan-li-mo-shi-jian-xi/"/>
      <url>/2019/10/20/2019-10-20-dan-li-mo-shi-jian-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="单例模式简析"><a href="#单例模式简析" class="headerlink" title="单例模式简析"></a>单例模式简析</h1><h2 id="1-什么是单例模式（Singleton-Pattern）"><a href="#1-什么是单例模式（Singleton-Pattern）" class="headerlink" title="1.什么是单例模式（Singleton Pattern）"></a>1.什么是单例模式（Singleton Pattern）</h2><p>单例，其实就是整个程序中只有1个实例</p><h2 id="2-有什么好处呢？"><a href="#2-有什么好处呢？" class="headerlink" title="2.有什么好处呢？"></a>2.有什么好处呢？</h2><p>优点：</p><ul><li>内存中只有1个实例，减少内存的开销</li><li>避免对资源的多重占用（比如说写文件操作）</li></ul><h2 id="3-有什么缺点呢？"><a href="#3-有什么缺点呢？" class="headerlink" title="3.有什么缺点呢？"></a>3.有什么缺点呢？</h2><ul><li>没有接口，不能继承</li><li>与单一职责原则冲突（一个类只应该关心内部逻辑，而不关心外面怎么来实例化）</li></ul><h2 id="4-适用场景"><a href="#4-适用场景" class="headerlink" title="4.适用场景"></a>4.适用场景</h2><p>下面举例子</p><ul><li>用于数据库连接池的设计，因为数据库连接池在打开或者关闭数据库连接的时候所引起的效率的损耗很大，用单例模式可以减少</li><li>线程池</li></ul><h2 id="5-单例模式的套路"><a href="#5-单例模式的套路" class="headerlink" title="5.单例模式的套路"></a>5.单例模式的套路</h2><ul><li>构造器私有</li><li>提供private的静态属性–&gt;存储对象的地址</li><li>提供公共的静态方法–&gt;获取属性</li></ul><h2 id="6-单例模式分为哪几类呢？"><a href="#6-单例模式分为哪几类呢？" class="headerlink" title="6.单例模式分为哪几类呢？"></a>6.单例模式分为哪几类呢？</h2><h3 id="1-懒汉式"><a href="#1-懒汉式" class="headerlink" title="1.懒汉式"></a>1.懒汉式</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>      <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton instance<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token function">Singleton</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>          instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> instance<span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre><p>线程不安全，延迟初始化，严格上不是单例模式</p><h3 id="2-饿汉式"><a href="#2-饿汉式" class="headerlink" title="2.饿汉式"></a>2.饿汉式</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>      <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token function">Singleton</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> instance<span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>线程安全，但是容易产生垃圾对象</p><h3 id="3-双重锁模式"><a href="#3-双重锁模式" class="headerlink" title="3.双重锁模式"></a>3.<strong>双重锁模式</strong></h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//注意这里用volatile修饰，避免重排序</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> Singleton singleton<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token function">Singleton</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>Singleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>              singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre><p>第一次是判断是为了避免不必要的同步，因为已经存在对象，第二次判断是为了进行同步，避免多线程问题</p><p>由于 singleton = new Singleton();  可能存在重排序的问题，什么是重排序，请往下看</p><h4 id="1-对象新建的过程是什么？"><a href="#1-对象新建的过程是什么？" class="headerlink" title="1.对象新建的过程是什么？"></a>1.对象新建的过程是什么？</h4><ol><li>开辟空间</li><li>初始化对象信息</li><li>返回对象的地址给引用</li></ol><h4 id="2-什么情况下会出现重排序呢？"><a href="#2-什么情况下会出现重排序呢？" class="headerlink" title="2.什么情况下会出现重排序呢？"></a>2.什么情况下会出现重排序呢？</h4><p>就是上述的第二步还没完成的时候，已经完成了第三步，这个时候就会获取到对象的空的引用</p><h3 id="4-静态内部类单例模式"><a href="#4-静态内部类单例模式" class="headerlink" title="4.静态内部类单例模式"></a>4.静态内部类单例模式</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>     <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">return</span> Inner<span class="token punctuation">.</span>instance<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Inner</span> <span class="token punctuation">{</span>          <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Singleton instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span> </code></pre><p>这样既可以懒加载，因为只有一个线程可以获得对象的初始化锁，又适用于多线程，书写难度也不是很大，较为推荐</p>]]></content>
      
      
      <categories>
          
          <category> java设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单例模式 </tag>
            
            <tag> java设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.4 树的存储结构</title>
      <link href="/2019/10/15/6.4-shu-de-cun-chu-jie-gou/"/>
      <url>/2019/10/15/6.4-shu-de-cun-chu-jie-gou/</url>
      
        <content type="html"><![CDATA[<h1 id="6-4-树的存储结构"><a href="#6-4-树的存储结构" class="headerlink" title="6.4 树的存储结构"></a>6.4 树的存储结构</h1><h2 id="6-4-1-双亲表示法"><a href="#6-4-1-双亲表示法" class="headerlink" title="6.4.1 双亲表示法"></a>6.4.1 双亲表示法</h2><blockquote><p>因为树一定有且仅有一个双亲。所以采用这种方法</p></blockquote><h3 id="1-容易找到双亲的方法"><a href="#1-容易找到双亲的方法" class="headerlink" title="1.容易找到双亲的方法"></a>1.容易找到双亲的方法</h3><h4 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1.数据结构"></a>1.数据结构</h4><p>假设以一组连续空间存储树的结点，同时在每个结点中，附设一个位置指示其双亲结点到链表中的位置。</p><p><img src="https://i.loli.net/2019/10/13/vaocCM9NxWSphZu.jpg" alt></p><p>data存储数据，parent是指针域，存储双亲在数组中的下标</p><p>结构定义代码如下图：</p><p><img src="https://i.loli.net/2019/10/13/oBpdTj9gFhmEk5H.jpg" alt></p><p><img src="https://i.loli.net/2019/10/13/lTepUDu8MJjr7XO.jpg" alt></p><h4 id="2-树结构转化为表结构例子："><a href="#2-树结构转化为表结构例子：" class="headerlink" title="2.树结构转化为表结构例子："></a>2.树结构转化为表结构例子：</h4><p><img src="https://i.loli.net/2019/10/13/E2rKz7ODHl1sStU.jpg" alt></p><h4 id="3-缺点是什么"><a href="#3-缺点是什么" class="headerlink" title="3.缺点是什么"></a>3.缺点是什么</h4><p>就是如果想知道孩子是谁的话，就要遍历整个结构了</p><h3 id="2-容易找到孩子的方法"><a href="#2-容易找到孩子的方法" class="headerlink" title="2.容易找到孩子的方法"></a>2.容易找到孩子的方法</h3><blockquote><p>思路是增加1个长子域</p></blockquote><p>我们增加一个结点最左边孩子的域，不妨叫它长子域，这样就可以很容易得到结点的孩子。如果没有孩子的结点，这个长子域就设置为-1，如表6-4-3所示。</p><p><img src="https://i.loli.net/2019/10/13/cQ5uYq2sBzmULkW.jpg" alt></p><p>缺点是什么？</p><p>缺点是兄弟之间的关系难以确定</p><h3 id="3-容易区别兄弟之间的关系的方法"><a href="#3-容易区别兄弟之间的关系的方法" class="headerlink" title="3.容易区别兄弟之间的关系的方法"></a>3.容易区别兄弟之间的关系的方法</h3><p>可以增加一个右兄弟域来体现兄弟关系，也就是说，每一个结点如果它存在右兄弟，则记录下右兄弟的下标。同样的，如果右兄弟不存在，则赋值为-1，如表6-4-4所示。</p><p><img src="https://i.loli.net/2019/10/13/qkBFrwnzp4PWOaA.jpg" alt></p><h3 id="4-要求同时关注双亲，孩子，兄弟怎么办？"><a href="#4-要求同时关注双亲，孩子，兄弟怎么办？" class="headerlink" title="4.要求同时关注双亲，孩子，兄弟怎么办？"></a>4.要求同时关注双亲，孩子，兄弟怎么办？</h3><p>还可以把次结构扩展为有双亲域、长子域、再有右兄弟域。</p><p><strong>存储结构的设计是一个非常灵活的过程。一个存储结构设计得是否合理，取决于基于该存储结构的运算是否适合，是否方便，时间复杂度好不好等</strong>。</p><h2 id="6-4-2-孩子表示法"><a href="#6-4-2-孩子表示法" class="headerlink" title="6.4.2 孩子表示法"></a>6.4.2 孩子表示法</h2><h3 id="1-当有多个孩子的时候怎么处理？"><a href="#1-当有多个孩子的时候怎么处理？" class="headerlink" title="1.当有多个孩子的时候怎么处理？"></a>1.当有多个孩子的时候怎么处理？</h3><p>考虑用多重链表，即<strong>每个结点有多个指针域</strong>，其中每个指针指向一棵子树的根结点，我们把这种方法叫做<strong>多重链表表示法</strong>。其实就是将他的孩子都用指针给指出来。</p><h3 id="2-方案1：以度数为指针域的个数（最大化处理）管够"><a href="#2-方案1：以度数为指针域的个数（最大化处理）管够" class="headerlink" title="2.方案1：以度数为指针域的个数（最大化处理）管够"></a>2.方案1：以度数为指针域的个数（最大化处理）管够</h3><p><img src="https://i.loli.net/2019/10/13/FNC9cw8eI4oHYbk.jpg" alt></p><p>缺点是：当度数相差很大的时候，浪费空间</p><h3 id="3-方案2：按需分配，省钱"><a href="#3-方案2：按需分配，省钱" class="headerlink" title="3.方案2：按需分配，省钱"></a>3.方案2：按需分配，省钱</h3><p>专门取一个位置来存储结点指针域的个数，如下图</p><p><img src="https://i.loli.net/2019/10/13/HJZ6vran4KcNido.jpg" alt></p><p>其中data为数据域，degree为度域，也就是存储该结点的孩子结点的个数，child1到childd为指针域，指向该结点的各个孩子的结点。</p><p><img src="https://i.loli.net/2019/10/13/OeYCjXUqdMIr7P9.jpg" alt></p><p>缺点：结构不统一，时间复杂度上升（相对方法1）</p><h3 id="4-孩子表示法"><a href="#4-孩子表示法" class="headerlink" title="4.孩子表示法"></a>4.孩子表示法</h3><blockquote><p>可以减少空指针的浪费和统一结构</p></blockquote><h4 id="1-孩子表示法是怎么样的？"><a href="#1-孩子表示法是怎么样的？" class="headerlink" title="1.孩子表示法是怎么样的？"></a>1.孩子表示法是怎么样的？</h4><p>其实是先将所有的结点都放在一个数组里面，然后再对每个结点的孩子建立一个单链表体现它们的关系</p><p>具体办法是：</p><p>把每个结点的<strong>孩子</strong>结点排列起来，以<strong>单链表</strong>作存储结构，则n个结点由n个孩子链表，如果是叶子结点则此单链表为空。然后<strong>n个头指针</strong>又<strong>组成</strong>一个<strong>线性表</strong>，采用顺序存储结构，存放进一个<strong>一维数组</strong>中，如图6-4-4所示。</p><p><img src="https://i.loli.net/2019/10/13/cOhVGSHYCIi4zmT.jpg" alt></p><p>为此设计两种结构：</p><h4 id="2-孩子结点"><a href="#2-孩子结点" class="headerlink" title="2.孩子结点"></a>2.孩子结点</h4><p>其中child是数据域，用来存储某个结点在表头数组中的下标。next是指针域，用来存储指向某结点的下一个孩子结点的指针。</p><p><img src="https://i.loli.net/2019/10/13/ZF5ASGX6jP2lerh.jpg" alt></p><h4 id="3-表头结点："><a href="#3-表头结点：" class="headerlink" title="3.表头结点："></a>3.表头结点：</h4><p>其中data是数据域，存储某结点的数据信息。firstchild是头指针域，存储该结点的孩子链表的头指针。</p><p><img src="https://i.loli.net/2019/10/13/T8X7Vq2mdLBStne.jpg" alt></p><h4 id="4-结构定义代码是怎样？"><a href="#4-结构定义代码是怎样？" class="headerlink" title="4.结构定义代码是怎样？"></a>4.结构定义代码是怎样？</h4><p><img src="https://i.loli.net/2019/10/13/n81AjeyPLSHFZOJ.jpg" alt></p><p><img src="https://i.loli.net/2019/10/13/fbzy321usTEFK7j.jpg" alt></p><p>表头和孩子的结构都类似，都是数据域加上指针域</p><h4 id="5-可不可以和找到双亲呢？"><a href="#5-可不可以和找到双亲呢？" class="headerlink" title="5.可不可以和找到双亲呢？"></a>5.可不可以和找到双亲呢？</h4><p>其实就是在表头加上个双亲就行了</p><p><img src="https://i.loli.net/2019/10/13/KVEZJQpIFwWYL26.jpg" alt></p><h2 id="6-4-3-孩子兄弟表示法"><a href="#6-4-3-孩子兄弟表示法" class="headerlink" title="6.4.3 孩子兄弟表示法"></a>6.4.3 孩子兄弟表示法</h2><h3 id="1-什么是孩子兄弟表示法"><a href="#1-什么是孩子兄弟表示法" class="headerlink" title="1.什么是孩子兄弟表示法"></a>1.什么是孩子兄弟表示法</h3><p>任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟。其实就是长子唯一，右兄弟也唯一。</p><p><img src="https://s2.ax1x.com/2019/10/13/ux5zGD.png" alt="ux5zGD.png"></p><p><img src="https://s2.ax1x.com/2019/10/13/uxIkZt.png" alt="uxIkZt.png"></p><h3 id="2-好处是什么？"><a href="#2-好处是什么？" class="headerlink" title="2.好处是什么？"></a>2.好处是什么？</h3><p>把复杂的树变成了二叉树</p><p><img src="https://s2.ax1x.com/2019/10/13/uxImRg.png" alt="uxImRg.png"></p>]]></content>
      
      
      <categories>
          
          <category> 大话数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大话数据结构 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.3 树的抽象数据类型</title>
      <link href="/2019/10/15/6.3-shu-de-chou-xiang-shu-ju-lei-xing/"/>
      <url>/2019/10/15/6.3-shu-de-chou-xiang-shu-ju-lei-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="6-3-树的抽象数据类型"><a href="#6-3-树的抽象数据类型" class="headerlink" title="6.3 树的抽象数据类型"></a>6.3 树的抽象数据类型</h1><h2 id="如图所示"><a href="#如图所示" class="headerlink" title="如图所示"></a>如图所示</h2><p><img src="https://i.loli.net/2019/10/13/Sj47DBQyFYKublL.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 大话数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大话数据结构 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.2 树的定义</title>
      <link href="/2019/10/15/6.2-shu-de-ding-yi/"/>
      <url>/2019/10/15/6.2-shu-de-ding-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="6-2-树的定义"><a href="#6-2-树的定义" class="headerlink" title="6.2 树的定义"></a>6.2 树的定义</h1><blockquote><p>树，个人觉得是一种从生活中抽象而成的数据结构，类似于我们现实生活中的树</p></blockquote><h2 id="树是什么？"><a href="#树是什么？" class="headerlink" title="树是什么？"></a>树是什么？</h2><h3 id="树（非空树），需要满足下面2个条件："><a href="#树（非空树），需要满足下面2个条件：" class="headerlink" title="树（非空树），需要满足下面2个条件："></a>树（非空树），需要满足下面2个条件：</h3><ol><li><strong>有且只有</strong>1个特点的节点的根结点</li><li>当n&gt;1时，其余结点可以分为m个<strong>互不相交</strong>的有限集，其中每个有限集本身又是树，成为子树</li></ol><p><img src="https://i.loli.net/2019/10/13/bLxwVNpzCcDsZhm.jpg" alt></p><h3 id="不是树的例子："><a href="#不是树的例子：" class="headerlink" title="不是树的例子："></a>不是树的例子：</h3><p><img src="https://i.loli.net/2019/10/13/Ui6tbdrL5MFJNKV.jpg" alt></p><h2 id="6-2-1-结点分类"><a href="#6-2-1-结点分类" class="headerlink" title="6.2.1 结点分类"></a>6.2.1 结点分类</h2><h3 id="1-什么是度"><a href="#1-什么是度" class="headerlink" title="1.什么是度"></a>1.什么是度</h3><p>结点拥有的子树数称为结点的度，度为0的结点称为叶结点，度不为0的结点称为非终端结点或分支结点</p><p>如图：</p><p><img src="https://i.loli.net/2019/10/13/H8nXLTfZOsewCAm.jpg" alt></p><h3 id="2-树的度是什么？"><a href="#2-树的度是什么？" class="headerlink" title="2.树的度是什么？"></a>2.树的度是什么？</h3><p>树内各结点的度的最大值,上图的度是3</p><h2 id="6-2-2-结点间关系"><a href="#6-2-2-结点间关系" class="headerlink" title="6.2.2 结点间关系"></a>6.2.2 结点间关系</h2><h3 id="1-什么是孩子，什么是双亲"><a href="#1-什么是孩子，什么是双亲" class="headerlink" title="1.什么是孩子，什么是双亲"></a>1.什么是孩子，什么是双亲</h3><p>A结点的<strong>子树的根结点</strong>B，是A的<strong>孩子</strong>，相应，A结点是B的<strong>双亲</strong>（为什么是双亲呢？因为对于结点来说，他的上面指向他自己的只有1个，双亲只有1个）</p><p>如图：</p><p><img src="https://i.loli.net/2019/10/13/xdh5MknpAriHlCb.jpg" alt></p><h3 id="2-什么是兄弟？什么是祖先？"><a href="#2-什么是兄弟？什么是祖先？" class="headerlink" title="2.什么是兄弟？什么是祖先？"></a>2.什么是兄弟？什么是祖先？</h3><p><strong>同一个双亲的孩子之间互称兄弟</strong>，<strong>结点的祖先是从根到该结点所经分支上的所有结点</strong>，简而言之就是，从上面来的指向它的结点的就是祖先</p><h2 id="6-2-3-树的其他相关概念"><a href="#6-2-3-树的其他相关概念" class="headerlink" title="6.2.3 树的其他相关概念"></a>6.2.3 树的其他相关概念</h2><h3 id="1-什么是树的层次？"><a href="#1-什么是树的层次？" class="headerlink" title="1.什么是树的层次？"></a>1.什么是树的层次？</h3><p>其实就是从根开始定义起，根为第一层，根的孩子为第二层。</p><p>如图：</p><p><img src="https://i.loli.net/2019/10/13/anqojCTQ1If5dg6.jpg" alt></p><h3 id="2-什么是树的深度？"><a href="#2-什么是树的深度？" class="headerlink" title="2.什么是树的深度？"></a>2.什么是树的深度？</h3><p><strong>树中结点的最大层次</strong></p><h3 id="3-什么是堂兄弟？"><a href="#3-什么是堂兄弟？" class="headerlink" title="3.什么是堂兄弟？"></a>3.什么是堂兄弟？</h3><p>就是双亲同层的结点，显然图6-2-6中的D、E、F是堂兄弟，</p><h3 id="4-什么是有序树"><a href="#4-什么是有序树" class="headerlink" title="4.什么是有序树"></a>4.什么是有序树</h3><p>如果将树中结点的各子树看成<strong>从左到右是有次序</strong>的，不能互换的，则称该树为有序树，否则称为无序树。</p><h3 id="5-什么是森林？"><a href="#5-什么是森林？" class="headerlink" title="5.什么是森林？"></a>5.什么是森林？</h3><p>是m(m&gt;=0)棵<strong>互不相交</strong>的<strong>树的集合</strong></p><h3 id="6-线性表和树的结构有什么不同？"><a href="#6-线性表和树的结构有什么不同？" class="headerlink" title="6.线性表和树的结构有什么不同？"></a>6.线性表和树的结构有什么不同？</h3><p><img src="https://i.loli.net/2019/10/13/ZRiJVHukgAo7K9Y.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 大话数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大话数据结构 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.3 栈的顺序存储结构及实现</title>
      <link href="/2019/10/14/4.3-zhan-de-shun-xu-cun-chu-jie-gou-ji-shi-xian/"/>
      <url>/2019/10/14/4.3-zhan-de-shun-xu-cun-chu-jie-gou-ji-shi-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="4-3-栈的顺序存储结构及实现"><a href="#4-3-栈的顺序存储结构及实现" class="headerlink" title="4.3 栈的顺序存储结构及实现"></a>4.3 栈的顺序存储结构及实现</h1><h2 id="1-栈的结构定义"><a href="#1-栈的结构定义" class="headerlink" title="1.栈的结构定义"></a>1.栈的结构定义</h2><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">int</span> SElemType<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>    SElemType data<span class="token punctuation">[</span>MAXSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> top<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/*用于栈顶指针*/</span><span class="token punctuation">}</span>SqStack<span class="token punctuation">;</span></code></pre><h2 id="2-进栈操作"><a href="#2-进栈操作" class="headerlink" title="2.进栈操作"></a>2.进栈操作</h2><pre class=" language-c"><code class="language-c">Status <span class="token function">Push</span><span class="token punctuation">(</span>SqStack <span class="token operator">*</span>S <span class="token punctuation">,</span>SElemType e<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token operator">-></span>top<span class="token operator">==</span>MAXSIZE<span class="token number">-1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//栈满</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    S<span class="token operator">-></span>top<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//栈顶指针增加</span>    S<span class="token operator">-></span>data<span class="token punctuation">[</span>S<span class="token operator">-></span>top<span class="token punctuation">]</span><span class="token operator">=</span>e<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将新插入元素赋值给栈顶空间</span>    <span class="token keyword">return</span> Ok<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="3-出栈操作"><a href="#3-出栈操作" class="headerlink" title="3.出栈操作"></a>3.出栈操作</h2><pre class=" language-c"><code class="language-c">Status <span class="token function">Pop</span><span class="token punctuation">(</span>SqStack <span class="token operator">*</span>S<span class="token punctuation">,</span>SElemType <span class="token operator">*</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token operator">-></span>top<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>    <span class="token keyword">return</span> error<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">*</span>e<span class="token operator">=</span>S<span class="token operator">-></span>data<span class="token punctuation">[</span>S<span class="token operator">-></span>top<span class="token punctuation">]</span><span class="token punctuation">;</span>     S<span class="token operator">-></span>top<span class="token operator">--</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//栈顶指针减1 </span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 大话数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大话数据结构 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.11 处理冲突的方法</title>
      <link href="/2019/10/13/8.11-chu-li-chong-tu-de-fang-fa/"/>
      <url>/2019/10/13/8.11-chu-li-chong-tu-de-fang-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="8-11-处理冲突的方法"><a href="#8-11-处理冲突的方法" class="headerlink" title="8.11 处理冲突的方法"></a>8.11 处理冲突的方法</h1><h2 id="8-11-1-开放定址法"><a href="#8-11-1-开放定址法" class="headerlink" title="8.11.1 开放定址法"></a>8.11.1 开放定址法</h2><h3 id="1-什么是开放定址法呢"><a href="#1-什么是开放定址法呢" class="headerlink" title="1.什么是开放定址法呢"></a>1.什么是开放定址法呢</h3><p>一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。</p><h3 id="公式为：fi-key-f-key-di-MOD-m-di-1-2-3-……-m-1"><a href="#公式为：fi-key-f-key-di-MOD-m-di-1-2-3-……-m-1" class="headerlink" title="公式为：fi(key) = (f(key)+di) MOD m (di=1,2,3,……,m-1)"></a>公式为：fi(key) = (f(key)+di) MOD m (di=1,2,3,……,m-1)</h3><h3 id="2-什么是线性探测法"><a href="#2-什么是线性探测法" class="headerlink" title="2.什么是线性探测法"></a>2.什么是线性探测法</h3><p>其实就是按顺序找下去地定址</p><h3 id="3-什么是堆积"><a href="#3-什么是堆积" class="headerlink" title="3.什么是堆积"></a>3.什么是堆积</h3><p>其实就是冲突的连环出现，我原本a有冲突，a的冲突解决了，b又和a有冲突了，本来都不是同义词却需要争夺一个地址的叫做堆积</p><h3 id="4-什么是二次探测法"><a href="#4-什么是二次探测法" class="headerlink" title="4.什么是二次探测法"></a>4.什么是二次探测法</h3><p>其实就是增加了平方和正负运算，</p><p>fi(key) = (f(key)+di) MOD m (di = 1 2, -1 2, 2 2, -2 2,……, q 2, -q 2, q &lt;= m/2) 这里的是指平方</p><h3 id="5-什么是随机探测法"><a href="#5-什么是随机探测法" class="headerlink" title="5.什么是随机探测法"></a>5.什么是随机探测法</h3><p>对于位移量 di 采用随机函数计算得到，我们称之为随机探测法。</p><h3 id="6-什么是伪随机数"><a href="#6-什么是伪随机数" class="headerlink" title="6.什么是伪随机数"></a>6.什么是伪随机数</h3><p>其实就是由随机种子按照某种随机算法，生成的数，</p><p>随机种子是以随机数作为对象的以真随机数（种子）为初始条件的随机数。一般以系统时间作为随机种子</p><h2 id="8-11-2-再散列函数法"><a href="#8-11-2-再散列函数法" class="headerlink" title="8.11.2 再散列函数法"></a>8.11.2 再散列函数法</h2><p>其实就是随机调用不同的散列函数</p><h2 id="8-11-3-链地址法"><a href="#8-11-3-链地址法" class="headerlink" title="8.11.3 链地址法"></a>8.11.3 链地址法</h2><p>就是在冲突的地址里面，生成1个链表，类似于HashMap</p><h2 id="8-11-4-公共溢出区法"><a href="#8-11-4-公共溢出区法" class="headerlink" title="8.11.4 公共溢出区法"></a>8.11.4 公共溢出区法</h2><p>其实就是把所有冲突的关键词存到一个公共区，查找的时候，当在普通区查不到，就到公共溢出区查</p>]]></content>
      
      
      <categories>
          
          <category> 大话数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大话数据结构 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.12 散列表查找实现</title>
      <link href="/2019/10/13/8.12-san-lie-biao-cha-zhao-shi-xian/"/>
      <url>/2019/10/13/8.12-san-lie-biao-cha-zhao-shi-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="8-12-散列表查找实现"><a href="#8-12-散列表查找实现" class="headerlink" title="8.12 散列表查找实现"></a>8.12 散列表查找实现</h1><h2 id="8-12-1-散列表查找算法实现"><a href="#8-12-1-散列表查找算法实现" class="headerlink" title="8.12.1 散列表查找算法实现"></a>8.12.1 散列表查找算法实现</h2><h3 id="1-定义结构"><a href="#1-定义结构" class="headerlink" title="1.定义结构"></a>1.定义结构</h3><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> OK 1</span><span class="token macro property">#<span class="token directive keyword">define</span> ERROR 0</span><span class="token macro property">#<span class="token directive keyword">define</span> TRUE 1</span><span class="token macro property">#<span class="token directive keyword">define</span> FALSE 0</span><span class="token macro property">#<span class="token directive keyword">define</span> MAXSIZE 100 </span><span class="token comment" spellcheck="true">/* 存储空间初始分配量 */</span><span class="token macro property">#<span class="token directive keyword">define</span> SUCCESS 1</span><span class="token macro property">#<span class="token directive keyword">define</span> UNSUCCESS 0</span><span class="token macro property">#<span class="token directive keyword">define</span> HASHSIZE 12 </span><span class="token comment" spellcheck="true">/* 定义散列表长为数组的长度 */</span><span class="token macro property">#<span class="token directive keyword">define</span> NULLKEY -32768 </span><span class="token keyword">typedef</span> <span class="token keyword">int</span> Status<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* Status是函数的类型,其值是函数结果状态代码，如OK等 */</span> <span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>   <span class="token keyword">int</span> <span class="token operator">*</span>elem<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 数据元素存储基址，动态分配数组 */</span>   <span class="token keyword">int</span> count<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/*  当前数据元素个数 */</span><span class="token punctuation">}</span>HashTable<span class="token punctuation">;</span></code></pre><h3 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2.初始化"></a>2.初始化</h3><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 初始化散列表 */</span>Status <span class="token function">InitHashTable</span><span class="token punctuation">(</span>HashTable <span class="token operator">*</span>H<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    m<span class="token operator">=</span>HASHSIZE<span class="token punctuation">;</span>    H<span class="token operator">-></span>count<span class="token operator">=</span>m<span class="token punctuation">;</span>    H<span class="token operator">-></span>elem<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>m<span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        H<span class="token operator">-></span>elem<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>NULLKEY<span class="token punctuation">;</span>     <span class="token keyword">return</span> OK<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="3-散列函数"><a href="#3-散列函数" class="headerlink" title="3.散列函数"></a>3.散列函数</h3><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 散列函数 */</span><span class="token keyword">int</span> <span class="token function">Hash</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> key <span class="token operator">%</span> m<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 除留余数法 */</span><span class="token punctuation">}</span></code></pre><h3 id="4-插入关键字进散列表"><a href="#4-插入关键字进散列表" class="headerlink" title="4./* 插入关键字进散列表 */"></a>4./* 插入关键字进散列表 */</h3><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 插入关键字进散列表 */</span><span class="token keyword">void</span> <span class="token function">InsertHash</span><span class="token punctuation">(</span>HashTable <span class="token operator">*</span>H<span class="token punctuation">,</span><span class="token keyword">int</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> addr <span class="token operator">=</span> <span class="token function">Hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 求散列地址 */</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>H<span class="token operator">-></span>elem<span class="token punctuation">[</span>addr<span class="token punctuation">]</span> <span class="token operator">!=</span> NULLKEY<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">/* 如果不为空，则冲突 */</span>    <span class="token punctuation">{</span>        addr <span class="token operator">=</span> <span class="token punctuation">(</span>addr<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> m<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 开放定址法的线性探测 */</span>    <span class="token punctuation">}</span>    H<span class="token operator">-></span>elem<span class="token punctuation">[</span>addr<span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 直到有空位后插入关键字 */</span><span class="token punctuation">}</span></code></pre><h3 id="5-散列表查找关键字"><a href="#5-散列表查找关键字" class="headerlink" title="5.散列表查找关键字"></a>5.散列表查找关键字</h3><pre class=" language-c"><code class="language-c">Status <span class="token function">SearchHash</span><span class="token punctuation">(</span>HashTable H<span class="token punctuation">,</span><span class="token keyword">int</span> key<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">*</span>addr<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token operator">*</span>addr <span class="token operator">=</span> <span class="token function">Hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 求散列地址 */</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>H<span class="token punctuation">.</span>elem<span class="token punctuation">[</span><span class="token operator">*</span>addr<span class="token punctuation">]</span> <span class="token operator">!=</span> key<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//当不是关键词,冲突了 </span>    <span class="token punctuation">{</span>        <span class="token operator">*</span>addr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>addr<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> m<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 开放定址法的线性探测 */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>H<span class="token punctuation">.</span>elem<span class="token punctuation">[</span><span class="token operator">*</span>addr<span class="token punctuation">]</span> <span class="token operator">==</span> NULLKEY <span class="token operator">||</span> <span class="token operator">*</span>addr <span class="token operator">==</span> <span class="token function">Hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//当散列查找的话，查找的是空的话，说明没有了，因为是空的都不存 </span><span class="token comment" spellcheck="true">/* 如果循环回到原点 */</span>            <span class="token keyword">return</span> UNSUCCESS<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 则说明关键字不存在 */</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> SUCCESS<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>查找相对于插入，就多了个空和回头的判断</p><h2 id="8-12-2-散列表查找性能分析"><a href="#8-12-2-散列表查找性能分析" class="headerlink" title="8.12.2 散列表查找性能分析"></a>8.12.2 散列表查找性能分析</h2><h3 id="1-时间复杂度是多少"><a href="#1-时间复杂度是多少" class="headerlink" title="1.时间复杂度是多少"></a>1.时间复杂度是多少</h3><p>O（1）</p><h3 id="2-取决于什么因素？"><a href="#2-取决于什么因素？" class="headerlink" title="2.取决于什么因素？"></a>2.取决于什么因素？</h3><ul><li>是否均匀</li><li>处理冲突的方法</li><li>装填因子</li></ul><h3 id="3-什么是装填因子"><a href="#3-什么是装填因子" class="headerlink" title="3.什么是装填因子"></a>3.什么是装填因子</h3><p>就是用来衡量散列表的装满的程度的数字，记录个数/长度=装填因子</p><p>装填因子越大，表明产生冲突的可能性越大</p>]]></content>
      
      
      <categories>
          
          <category> 大话数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大话数据结构 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.10 散列函数的构造方法</title>
      <link href="/2019/10/13/8.10-san-lie-han-shu-de-gou-zao-fang-fa/"/>
      <url>/2019/10/13/8.10-san-lie-han-shu-de-gou-zao-fang-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="8-10-散列函数的构造方法"><a href="#8-10-散列函数的构造方法" class="headerlink" title="8.10 散列函数的构造方法"></a>8.10 散列函数的构造方法</h1><blockquote><p>什么才是好的散列函数呢？</p><ul><li>计算简单</li><li>地址分布均匀</li></ul></blockquote><h2 id="8-10-1-直接定址法"><a href="#8-10-1-直接定址法" class="headerlink" title="8.10.1.直接定址法"></a>8.10.1.直接定址法</h2><p>就是通过关键字的某个线性函数值来作为散列地址</p><p>例如：</p><p>f(key)=a*key+b</p><h3 id="1-优点是："><a href="#1-优点是：" class="headerlink" title="1.优点是："></a>1.优点是：</h3><p>简单，均匀，不会产生冲突</p><h3 id="2-缺点是："><a href="#2-缺点是：" class="headerlink" title="2.缺点是："></a>2.缺点是：</h3><p>需要事先知道关键字分布情况，</p><h3 id="3-适合什么？"><a href="#3-适合什么？" class="headerlink" title="3.适合什么？"></a>3.适合什么？</h3><p>查找数据量少且连续的，知道分布</p><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="8-10-2-数字分析法"><a href="#8-10-2-数字分析法" class="headerlink" title="8.10.2 数字分析法"></a>8.10.2 数字分析法</h2><h3 id="1-什么是数字分析法呢"><a href="#1-什么是数字分析法呢" class="headerlink" title="1.什么是数字分析法呢"></a>1.什么是数字分析法呢</h3><p>其实就是找到数字分布的规律，然后抽取其中的不容易重复的一部分作为地址，例如手机号码的后4位</p><h3 id="2-适用什么？"><a href="#2-适用什么？" class="headerlink" title="2.适用什么？"></a>2.适用什么？</h3><p>位数大，知道分布</p><h2 id="8-10-3-平方取中法"><a href="#8-10-3-平方取中法" class="headerlink" title="8.10.3 平方取中法"></a>8.10.3 平方取中法</h2><h3 id="1-是什么意思呢"><a href="#1-是什么意思呢" class="headerlink" title="1.是什么意思呢"></a>1.是什么意思呢</h3><p>其实就是将数字平方后，取中间的3位数字，</p><h3 id="2-适用什么？-1"><a href="#2-适用什么？-1" class="headerlink" title="2.适用什么？"></a>2.适用什么？</h3><p>位数小，不知道分布</p><h2 id="8-10-4-折叠法"><a href="#8-10-4-折叠法" class="headerlink" title="8.10.4 折叠法"></a>8.10.4 折叠法</h2><h3 id="1-什么是折叠法"><a href="#1-什么是折叠法" class="headerlink" title="1.什么是折叠法"></a>1.什么是折叠法</h3><p>其实就是将关键字分割成位数相等的几部分，然后再叠加求和，取后3位为散列地址（散列表表长是3），有时候，可以一端向另一端折叠</p><p>例如：9876543210，变成：987+456+321=1566取后3位</p><h3 id="2-适用什么"><a href="#2-适用什么" class="headerlink" title="2.适用什么"></a>2.适用什么</h3><p>位数大，不知道分布</p><h2 id="8-10-5-除留余数法"><a href="#8-10-5-除留余数法" class="headerlink" title="8.10.5 除留余数法"></a>8.10.5 除留余数法</h2><h3 id="1-是什么？"><a href="#1-是什么？" class="headerlink" title="1.是什么？"></a>1.是什么？</h3><p>其实就是除某个数取余，通常取小于或者等于表长的最大质数</p><p>例如:某散列表的长度为100，散列函数H(k)=k%P,则P通常情况下最好选择哪个呢？</p><p>A、91 B、93 C、97 D、99</p><p>选97</p><h2 id="8-10-6-随机数法"><a href="#8-10-6-随机数法" class="headerlink" title="8.10.6 随机数法"></a>8.10.6 随机数法</h2><h3 id="1-是什么"><a href="#1-是什么" class="headerlink" title="1.是什么"></a>1.是什么</h3><p>其实就是取随机数</p><p>random(key)</p><h3 id="2-适用范围"><a href="#2-适用范围" class="headerlink" title="2.适用范围"></a>2.适用范围</h3><p>其实就是关键字的长度不等的时候</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>怎么选择呢</p><p>其实考虑因素有几个</p><ul><li>计算地址的时间</li><li>关键字的长度</li><li>散列表的大小</li><li>分布情况</li><li>查找的概率</li></ul>]]></content>
      
      
      <categories>
          
          <category> 大话数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大话数据结构 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.9 散列表查找（哈希表）概述</title>
      <link href="/2019/10/13/8.9-san-lie-biao-cha-zhao-ha-xi-biao-gai-shu/"/>
      <url>/2019/10/13/8.9-san-lie-biao-cha-zhao-ha-xi-biao-gai-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="8-9-散列表查找（哈希表）概述"><a href="#8-9-散列表查找（哈希表）概述" class="headerlink" title="8.9 散列表查找（哈希表）概述"></a>8.9 散列表查找（哈希表）概述</h1><h2 id="8-9-1-散列查找定义"><a href="#8-9-1-散列查找定义" class="headerlink" title="8.9.1 散列查找定义"></a>8.9.1 散列查找定义</h2><h3 id="1-什么是散列技术"><a href="#1-什么是散列技术" class="headerlink" title="1.什么是散列技术"></a>1.什么是散列技术</h3><p>散列技术其实是存储位置和关键字的对应关系，一个关键字对应1个存储位置</p><h3 id="2-什么是哈希表"><a href="#2-什么是哈希表" class="headerlink" title="2.什么是哈希表"></a>2.什么是哈希表</h3><p>采用散列技术将记录存储在一块连续的内存空间里面，这个连续的内存空间就是哈希表</p><h2 id="8-9-2-散列表查找步骤"><a href="#8-9-2-散列表查找步骤" class="headerlink" title="8.9.2 散列表查找步骤"></a>8.9.2 散列表查找步骤</h2><ul><li>存储的时候，首先用散列技术计算出地址，然后在计算出来的地址里面存数据</li><li>查找的时候，首先用散列技术计算关键字的地址，然后在地址里面取数据</li></ul><h3 id="2-适用范围是什么"><a href="#2-适用范围是什么" class="headerlink" title="2.适用范围是什么"></a>2.适用范围是什么</h3><p>不适合范围查找，例如18-35岁，最大岁</p><p>不适合一个关键词对应很多一样类别的查找，例如：男生，女生</p><h3 id="3-什么是冲突"><a href="#3-什么是冲突" class="headerlink" title="3.什么是冲突"></a>3.什么是冲突</h3><p>其实就是不同的关键字，但是他们的地址相同，就是冲突</p>]]></content>
      
      
      <categories>
          
          <category> 大话数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大话数据结构 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.12 循环队列</title>
      <link href="/2019/10/13/4.12-xun-huan-dui-lie/"/>
      <url>/2019/10/13/4.12-xun-huan-dui-lie/</url>
      
        <content type="html"><![CDATA[<h1 id="4-12-循环队列"><a href="#4-12-循环队列" class="headerlink" title="4.12 循环队列"></a>4.12 循环队列</h1><h2 id="1-队列顺序存储的不足"><a href="#1-队列顺序存储的不足" class="headerlink" title="1.队列顺序存储的不足"></a>1.队列顺序存储的不足</h2><p>如果队头有个人走了的话，就需要所有元素向前移动，这样效率太低了</p><p>但是如果，队头有人走了的话，就把下一个人当作队头的话，原来的队头的位置又会空着，这样也不好</p><h2 id="2-什么是假溢出"><a href="#2-什么是假溢出" class="headerlink" title="2.什么是假溢出"></a>2.什么是假溢出</h2><p>其实就是队头没坐满，但是队尾已经没有位置了</p><h2 id="3-循环队列的定义是什么"><a href="#3-循环队列的定义是什么" class="headerlink" title="3.循环队列的定义是什么"></a>3.循环队列的定义是什么</h2><p>头尾相接的队列</p><h2 id="4-什么时候队列满了呢"><a href="#4-什么时候队列满了呢" class="headerlink" title="4.什么时候队列满了呢"></a>4.什么时候队列满了呢</h2><ol><li>设置一个标志flag,当front==rear，且flag=0时，队列为空，当front==rear,且flag=1的时候为满</li><li>不允许全满的情况出现，当队列满的时候，存在一个空闲单元</li><li>(rear+1)%QueneSize==front;这样的话，就可以综合rear&gt;front的情况了</li></ol><h2 id="5-计算队列的长度的方法"><a href="#5-计算队列的长度的方法" class="headerlink" title="5.计算队列的长度的方法"></a>5.计算队列的长度的方法</h2><p>(rear-front+QueueSize)%QueueSIze </p><h2 id="6-入队的代码是怎样的"><a href="#6-入队的代码是怎样的" class="headerlink" title="6.入队的代码是怎样的"></a>6.入队的代码是怎样的</h2><pre class=" language-c"><code class="language-c">Status <span class="token function">EnQuene</span><span class="token punctuation">(</span>SqQueue <span class="token operator">*</span>Q，QElemType e<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Q<span class="token operator">-></span>rear<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>MAXSIZE<span class="token operator">==</span>Q<span class="token operator">-></span>front<span class="token punctuation">)</span>        <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//队列满了</span>    Q<span class="token operator">-></span>data<span class="token punctuation">[</span>Q<span class="token operator">-></span>rear<span class="token punctuation">]</span><span class="token operator">=</span>e<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将元素e赋值给队尾</span>    Q<span class="token operator">-></span>rear<span class="token operator">=</span><span class="token punctuation">(</span>Q<span class="token operator">-></span>rear<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>MAXSIZE<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将指针后移一位</span>    <span class="token keyword">return</span> Ok<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="7-出队的代码是怎样的"><a href="#7-出队的代码是怎样的" class="headerlink" title="7.出队的代码是怎样的"></a>7.出队的代码是怎样的</h2><pre class=" language-c"><code class="language-c">Status <span class="token function">EnQuene</span><span class="token punctuation">(</span>SqQueue <span class="token operator">*</span>Q，QElemType e<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Q<span class="token operator">-></span>rear<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>MAXSIZE<span class="token operator">==</span>Q<span class="token operator">-></span>front<span class="token punctuation">)</span>        <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//队列满了</span>  <span class="token operator">*</span>e<span class="token operator">=</span>Q<span class="token operator">-></span>data<span class="token punctuation">[</span>Q<span class="token operator">-></span>front<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将队头元素赋值给e</span>    Q<span class="token operator">-></span>front<span class="token operator">=</span><span class="token punctuation">(</span>Q<span class="token operator">-></span>front<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>MAXSIZE<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将front指针向后移动1位，如果到最后则到最前面</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 大话数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大话数据结构 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.8 栈的应用</title>
      <link href="/2019/10/13/4.8-zhan-de-ying-yong/"/>
      <url>/2019/10/13/4.8-zhan-de-ying-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="4-8-栈的应用"><a href="#4-8-栈的应用" class="headerlink" title="4.8 栈的应用"></a>4.8 栈的应用</h1><blockquote><p>栈的应用有哪些呢？1.是递归 2.是后缀表示法</p></blockquote><h2 id="1-为什么栈和递归有关系呢？"><a href="#1-为什么栈和递归有关系呢？" class="headerlink" title="1.为什么栈和递归有关系呢？"></a>1.为什么栈和递归有关系呢？</h2><p>其实递归是存储某些数据，后面又以存储的逆序恢复这些数据，显然符合栈的数据结构</p><h2 id="2-后缀表示法定义"><a href="#2-后缀表示法定义" class="headerlink" title="2.后缀表示法定义"></a>2.后缀表示法定义</h2><h3 id="1-什么是后缀表示法"><a href="#1-什么是后缀表示法" class="headerlink" title="1.什么是后缀表示法"></a>1.什么是后缀表示法</h3><p>其实就是不要括号的表示法，逆波兰法，</p><h3 id="2-后缀表达式的计算是怎样的呢"><a href="#2-后缀表达式的计算是怎样的呢" class="headerlink" title="2.后缀表达式的计算是怎样的呢"></a>2.后缀表达式的计算是怎样的呢</h3><p>从左到右遍历，遇到数字就出栈，遇到符合，就将栈顶两个数字出栈进行运算，运算结果进栈</p><h3 id="3-中缀表达式怎么转后缀表达式呢"><a href="#3-中缀表达式怎么转后缀表达式呢" class="headerlink" title="3.中缀表达式怎么转后缀表达式呢"></a>3.中缀表达式怎么转后缀表达式呢</h3><p>如果是数字，直接出栈，如果是符号的话，和栈顶符号进行比较，如果优先级大于栈顶符号的话，就入栈，如果优先级小于栈顶符号或者是右括号的话，就依次出栈（右括号的话，出栈到左括号）</p>]]></content>
      
      
      <categories>
          
          <category> 大话数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大话数据结构 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.7 栈的作用</title>
      <link href="/2019/10/13/4.7-zhan-de-zuo-yong/"/>
      <url>/2019/10/13/4.7-zhan-de-zuo-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="4-7-栈的作用"><a href="#4-7-栈的作用" class="headerlink" title="4.7 栈的作用"></a>4.7 栈的作用</h1><h2 id="为什么要用栈呢？"><a href="#为什么要用栈呢？" class="headerlink" title="为什么要用栈呢？"></a>为什么要用栈呢？</h2><p>其实栈，简化了程序设计的问题，划分的了不同关注层次，使思考范围聚集于问题核心</p>]]></content>
      
      
      <categories>
          
          <category> 大话数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大话数据结构 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.6 栈的链式存储结构及实现</title>
      <link href="/2019/10/13/4.6-zhan-de-lian-shi-cun-chu-jie-gou-ji-shi-xian/"/>
      <url>/2019/10/13/4.6-zhan-de-lian-shi-cun-chu-jie-gou-ji-shi-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="4-6-栈的链式存储结构及实现"><a href="#4-6-栈的链式存储结构及实现" class="headerlink" title="4.6 栈的链式存储结构及实现"></a>4.6 栈的链式存储结构及实现</h1><h2 id="1-什么是链栈呢"><a href="#1-什么是链栈呢" class="headerlink" title="1.什么是链栈呢"></a>1.什么是链栈呢</h2><p>其实很像链表，不过那个栈顶指针和头指针基本一样，所以对于链栈来说，不需要头指针，但是他其实方式是和链表的头插法是一样的，就是先来的在链表尾部，最后来的在链表头</p><h2 id="2-链栈的结构代码是怎样？"><a href="#2-链栈的结构代码是怎样？" class="headerlink" title="2.链栈的结构代码是怎样？"></a>2.链栈的结构代码是怎样？</h2><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> StackNode<span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//这个是链表</span>    SElemType data<span class="token punctuation">;</span>    <span class="token keyword">struct</span> StackNode <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span>StackNode<span class="token punctuation">,</span><span class="token operator">*</span>LinkStackPtr<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> LinkStack<span class="token punctuation">{</span>    LinkStackPtr top<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//栈顶指针</span>    <span class="token keyword">int</span> count<span class="token punctuation">;</span><span class="token punctuation">}</span>LinkStack<span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 大话数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大话数据结构 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.5 两栈共享空间</title>
      <link href="/2019/10/13/4.5-liang-zhan-gong-xiang-kong-jian/"/>
      <url>/2019/10/13/4.5-liang-zhan-gong-xiang-kong-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="4-5-两栈共享空间"><a href="#4-5-两栈共享空间" class="headerlink" title="4.5 两栈共享空间"></a>4.5 两栈共享空间</h1><h2 id="1-栈的缺点"><a href="#1-栈的缺点" class="headerlink" title="1.栈的缺点"></a>1.栈的缺点</h2><p>就是必须事先确定存储空间的大小，</p><h2 id="2-解决上面的缺点怎么办？"><a href="#2-解决上面的缺点怎么办？" class="headerlink" title="2.解决上面的缺点怎么办？"></a>2.解决上面的缺点怎么办？</h2><p>用两栈共享空间来解决，就是用1个数组来存储两个栈，要求是2个栈的类型相同</p><p>一个栈底是数组的开端，另一个栈的栈底是数组的结尾，</p><h2 id="3-什么时候会满呢"><a href="#3-什么时候会满呢" class="headerlink" title="3.什么时候会满呢"></a>3.什么时候会满呢</h2><p>就是两个栈顶见面的时候，就是S-&gt;top+1==S-&gt;top2</p><h2 id="4-两栈共享空间的结构是什么呢？"><a href="#4-两栈共享空间的结构是什么呢？" class="headerlink" title="4.两栈共享空间的结构是什么呢？"></a>4.两栈共享空间的结构是什么呢？</h2><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> data<span class="token punctuation">[</span>Max<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> top1<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//栈顶1</span>    <span class="token keyword">int</span> top2<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//栈顶2 </span><span class="token punctuation">}</span></code></pre><p>插入方法</p><pre class=" language-c"><code class="language-c">Status <span class="token function">Push</span><span class="token punctuation">(</span>SqDoubleStack <span class="token operator">*</span>S<span class="token punctuation">,</span>SElemType e<span class="token punctuation">,</span><span class="token keyword">int</span> number<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token operator">-></span>top1<span class="token operator">+</span><span class="token number">1</span><span class="token operator">==</span>S<span class="token operator">-></span>top2<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//栈满</span><span class="token keyword">if</span><span class="token punctuation">(</span>stackNumber<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//栈1中有元素进栈</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token operator">-></span>top1<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//空栈，溢出</span>    <span class="token punctuation">}</span>    S<span class="token operator">-></span>data<span class="token punctuation">[</span><span class="token operator">++</span>S<span class="token operator">-></span>top1<span class="token punctuation">]</span><span class="token operator">=</span>e<span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>number<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//栈2中有元素进栈</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token operator">-></span>top2<span class="token operator">==</span>MAX<span class="token punctuation">)</span>        <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//空栈</span>       S<span class="token operator">-></span>data<span class="token punctuation">[</span><span class="token operator">--</span>S<span class="token operator">-></span>top2<span class="token punctuation">]</span><span class="token operator">=</span>e<span class="token punctuation">;</span><span class="token punctuation">}</span>     <span class="token punctuation">}</span></code></pre><p>出栈是</p><p>*e=S-&gt;data[S-&gt;top2++];</p>]]></content>
      
      
      <categories>
          
          <category> 大话数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大话数据结构 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.2 栈的定义</title>
      <link href="/2019/10/13/4.2-zhan-de-ding-yi/"/>
      <url>/2019/10/13/4.2-zhan-de-ding-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="4-2-栈的定义"><a href="#4-2-栈的定义" class="headerlink" title="4.2 栈的定义"></a>4.2 栈的定义</h1><h2 id="1-什么是栈呢"><a href="#1-什么是栈呢" class="headerlink" title="1.什么是栈呢"></a>1.什么是栈呢</h2><p>栈是限定只能在表尾进行操作的线性表</p><p>后进先出</p><h2 id="2-出栈的顺序只有1种吗？"><a href="#2-出栈的顺序只有1种吗？" class="headerlink" title="2.出栈的顺序只有1种吗？"></a>2.出栈的顺序只有1种吗？</h2><p>不是，有很多</p>]]></content>
      
      
      <categories>
          
          <category> 大话数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大话数据结构 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第4章 栈和队列 目录</title>
      <link href="/2019/10/13/di-4-zhang-zhan-he-dui-lie/"/>
      <url>/2019/10/13/di-4-zhang-zhan-he-dui-lie/</url>
      
        <content type="html"><![CDATA[<h1 id="第4章-栈和队列"><a href="#第4章-栈和队列" class="headerlink" title="第4章 栈和队列"></a>第4章 栈和队列</h1><h2 id="1-栈的定义"><a href="#1-栈的定义" class="headerlink" title="1.栈的定义"></a>1.栈的定义</h2><h2 id="2-抽象数据类型"><a href="#2-抽象数据类型" class="headerlink" title="2.抽象数据类型"></a>2.抽象数据类型</h2><h2 id="3-顺序存储结构及其实现"><a href="#3-顺序存储结构及其实现" class="headerlink" title="3.顺序存储结构及其实现"></a>3.顺序存储结构及其实现</h2><h2 id="4-两栈共享空间"><a href="#4-两栈共享空间" class="headerlink" title="4.两栈共享空间"></a>4.两栈共享空间</h2><h2 id="5-栈的链式存储结构及实现"><a href="#5-栈的链式存储结构及实现" class="headerlink" title="5.栈的链式存储结构及实现"></a>5.栈的链式存储结构及实现</h2><h2 id="6-栈的作用"><a href="#6-栈的作用" class="headerlink" title="6.栈的作用"></a>6.栈的作用</h2><h2 id="7-递归"><a href="#7-递归" class="headerlink" title="7.递归"></a>7.递归</h2><h2 id="8-四则运算表达式求值"><a href="#8-四则运算表达式求值" class="headerlink" title="8.四则运算表达式求值"></a>8.四则运算表达式求值</h2><h2 id="9-队列定义"><a href="#9-队列定义" class="headerlink" title="9.队列定义"></a>9.队列定义</h2><h2 id="10-队列抽象数据类型"><a href="#10-队列抽象数据类型" class="headerlink" title="10.队列抽象数据类型"></a>10.队列抽象数据类型</h2><h2 id="11-循环队列"><a href="#11-循环队列" class="headerlink" title="11.循环队列"></a>11.循环队列</h2><h2 id="12-链式存储结构及其实现"><a href="#12-链式存储结构及其实现" class="headerlink" title="12.链式存储结构及其实现"></a>12.链式存储结构及其实现</h2>]]></content>
      
      
      <categories>
          
          <category> 大话数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大话数据结构 </tag>
            
            <tag> 第4章 栈和队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.7 KMP模式匹配算法</title>
      <link href="/2019/10/13/5.7-kmp-mo-shi-pi-pei-suan-fa/"/>
      <url>/2019/10/13/5.7-kmp-mo-shi-pi-pei-suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="5-7-KMP模式匹配算法"><a href="#5-7-KMP模式匹配算法" class="headerlink" title="5.7 KMP模式匹配算法"></a>5.7 KMP模式匹配算法</h1><blockquote><p>什么是KMP模式匹配算法?</p><p>其实就是1个模式匹配算法，<strong>大大避免重复遍历</strong>，简称<strong>KMP算法</strong></p></blockquote><h2 id="5-7-1-算法原理"><a href="#5-7-1-算法原理" class="headerlink" title="5.7.1 算法原理"></a>5.7.1 算法原理</h2><p>1.我们先假设一种情况，这种情况是子串<strong>没有重复</strong>的，主串<strong>S=”abcdefgab”</strong>，我们要匹配的<strong>T=”abcdex”</strong>，那么如果用前面的朴素算法的话，如图所示</p><p><img src="https://i.loli.net/2019/10/13/O85ylgkjHvbaCRV.jpg" alt></p><p>可仔细观察发现，子串T来说，”abcdex”首字母”a”与后面的串”bcdex”中任意一个字符都不相等，就是子串T没有重复的，</p><p>那么对于图5-7-1的(1)来说，前五位字符分别相等，意味着子串T的首字符”a”不可能与S串的第2位到第5位的字符相等。在图5-7-1中，(2)(3)(4)(5)的判断都是多余。我们直接跳到6这一步</p><p>2.我们再假设第2种情况，这种情况是子串<strong>有重复</strong>的，<strong>S=”abcabcabc”</strong>，<strong>T=”abcabx”</strong>,如图</p><p><img src="https://i.loli.net/2019/10/13/LDkKFNjgnmT6Gox.jpg" alt></p><p>由上面的经验，我们发现2，3步（<strong>重复出现之前</strong>的步骤）都是多余的，又因为第四位的”a”和第五位的”b”已经与主串S中的相应位置比较过了，是相等的，因此可以断定，T的首字符”a”、第二位的字符”b”与S的第四位字符和第五位字符也不需要比较了，肯定也是相等的，所以(4)(5)这两个比较得出字符相等的步骤也可以省略。</p><p>简化后的图：</p><p><img src="https://i.loli.net/2019/10/13/xeMEwg8vkf5GOVb.jpg" alt></p><p>3.你明白什么是<strong>避免不必要的回溯</strong>了吗？</p><p>上面的例子很好说明了<strong>避免不必要的回溯</strong>，但是我们思考下，主串的i（当前位置下标）会不会回头走的呢？</p><p>很显然，不会，在第一个例子中，i一开始是1，一轮循环后，就到了6，类似于：“好马不吃回头草”</p><p>子串的位标j会吃回头草吗？</p><p><strong>通过观察也可发现，我们屡屡提到了T串的首字符与自身后面字符的比较，T串如果自身重复，发现如果有相等字符，j值的变化就会不相同</strong>，也就是说，这个<strong>j值的变化</strong>与主串其实没什么关系，关键就<strong>取决于T串的结构中是否有重复</strong>（<strong>相似度</strong>）的问题。</p><p>我们把T串各个位置的j值的变化，定义为一个数组next，那么next的长度就是T串的长度（因为next是T串各个元素位置的变化）,<strong>next的意思就是T串，j位置每次回溯的位置</strong>（<strong>回头吃草的位置</strong>），这里我们暂时不深究next数组中每个元素的值，我们可以定义一个函数：</p><h2 id="5-7-2-next数组推导"><a href="#5-7-2-next数组推导" class="headerlink" title="5.7.2 next数组推导"></a>5.7.2 next数组推导</h2><h3 id="先看例子："><a href="#先看例子：" class="headerlink" title="先看例子："></a>先看例子：</h3><h4 id="1-T-”abcdex”"><a href="#1-T-”abcdex”" class="headerlink" title="1.T=”abcdex”"></a>1.T=”abcdex”</h4><p>注意：我们观察的时候，看到j位置前面的字符就行了，比如说j=2，是看j=2之前的字符”a“</p><p><img src="https://i.loli.net/2019/10/13/pUoN2gY5zWO8chl.jpg" alt></p><ul><li>1)当j=1时，next[1]=0;</li><li>2)当j=2时，j由1到j-1（<strong>j的前一个字符</strong>）就只有字符”a”，属于其他情况next[2]=1;</li><li>3)当j=3时，j由1到j-1串是”ab”，显然”a”与”b”<strong>不相等</strong>，属其他情况，next[3]=<strong>1;</strong></li><li>4)以后同理，所以最终此T串的next[j]为011111。</li></ul><h3 id="2-T-”abcabx”"><a href="#2-T-”abcabx”" class="headerlink" title="2.T=”abcabx”"></a>2.T=”abcabx”</h3><p>注意：当我们看重复的时候，是看<strong>顺序重复</strong>，不是回文重复，例如：”abcab”（顺序重复）,这样重复的元素个数是2，”abcba”（回文重复）这样重复的元素只有:”a”</p><p>当<strong>出现重复</strong>的时候，<strong>next[j]的值是重复的元素个数+1</strong></p><p><img src="https://i.loli.net/2019/10/13/yWwtDC4xiLPAufM.jpg" alt></p><ul><li>1)当j=1时，next[1]=0;</li><li>2)当j=2时，同上例说明，next[2]=1;</li><li>3)当j=3时，同上，next[3]=1;</li><li>4)当j=4时，同上，next[4]=1;</li><li>5)当j=5时，此时j由1到j-1的串是”abca”，前缀字符”a”与后缀字符”a”相等，因此可推算出k值为2，因此next[5]=2;</li><li>6)当j=6时，j由1到j-1的串是”abcab”，由于前缀字符”ab”与后缀”ab”相等，所以next[6]=3。</li></ul><h3 id="3-T-”ababaaaba”"><a href="#3-T-”ababaaaba”" class="headerlink" title="3.T=”ababaaaba”"></a>3.T=”ababaaaba”</h3><p>注意：重复要看在末尾位置的重复，中间位置没有接到末尾的重复不算，比如说，T=”ababaaaba”中，如果看，第1到第3位置的aba和第3到第5位置的aba重复，这样就是错的，因为第3到第5位置的aba不在末尾</p><p><img src="https://i.loli.net/2019/10/13/ZNVKAWQzh7S3cPO.jpg" alt></p><ul><li>1)当j=1时，next[1]=0;</li><li>2)当j=2时，同上next[2]=1;</li><li>3)当j=3时，同上next[3]=1;</li><li>4)当j=4时，j由1到j-1的串是”aba”，前缀字符”a”与后缀字符”a”相等，next[4]=2;</li><li>5)当j=5时，j由1到j-1的串是”abab”，由于前缀字符”ab”与后缀”ab”相等，所以next[5]=3;</li><li>6)当j=6时，j由1到j-1的串的”ababa”，由于前缀字符”aba”与后缀”aba”相等，所以next[6]=4;</li><li>7)当j=7时，j由1到j-1的串是”ababaa”，由于前缀字符”ab”与后缀”aa”并不相等，只有”a”相等，所以next[7]=2;</li><li>8)当j=8时，j由1到j-1的串是”ababaaa”，只有”a”相等，所以next[8]=2;</li><li>9)当j=9时，j由1到j-1的串是”ababaaab”，由于前缀字符”ab”与后缀”ab”相等，所以next[9]=3</li></ul><h3 id="4-T-”aaaaaaaab”"><a href="#4-T-”aaaaaaaab”" class="headerlink" title="4.T=”aaaaaaaab”"></a>4.T=”aaaaaaaab”</h3><p>注意：比如看,aaaa的时候，重复的元素个数是多少呢？</p><p>有的人说是4，你看它全是重复的，这样其实是不对的</p><p>正确答案是3，有规定，<strong>重复元素不能是整个字符串的元素</strong>，所以这里只是3(“aaa”)</p><p><img src="https://i.loli.net/2019/10/13/d4yZwgDnW6vqKPe.jpg" alt></p><ul><li>1)当j=1时，next[1]=0;</li><li>2)当j=2时，同上next[2]=1;</li><li>3)当j=3时，j由1到j-1的串是”aa”，前缀字符”a”与后缀字符”a”相等，next[3]=2;</li><li>4)当j=4时，j由1到j-1的串是”aaa”，由于前缀字符”aa”与后缀”aa”相等，所以next[4]=3;</li><li>5)……</li><li>6)当j=9时，j由1到j-1的串是”aaaaaaaa”，由于前缀字符”aaaaaaa”与后缀”aaaaaaa”相等，所以next[9]=8。</li></ul><h2 id="5-7-3-算法实现"><a href="#5-7-3-算法实现" class="headerlink" title="5.7.3 算法实现"></a>5.7.3 算法实现</h2><blockquote><p>看了这么多，其实这个算法最核心的部分就是next数组了，也就是每次j要回溯的位置（回头吃草的位置）</p></blockquote><h3 id="1-得到next数组的代码"><a href="#1-得到next数组的代码" class="headerlink" title="1.得到next数组的代码"></a>1.得到next数组的代码</h3><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 通过计算返回子串T的next数组。 */</span><span class="token keyword">void</span> <span class="token function">get_next</span><span class="token punctuation">(</span>String T<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">;</span>      i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>      j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>      next<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">&lt;</span>T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">/* 此处T[0]表示串T的长度 */</span>     <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">||</span> T<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span> T<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">/* T[i]表示后缀的单个字符，T[j]表示前缀的单个字符 */</span>        <span class="token punctuation">{</span>              <span class="token operator">++</span>i<span class="token punctuation">;</span>              <span class="token operator">++</span>j<span class="token punctuation">;</span>              next<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>        <span class="token punctuation">}</span>         <span class="token keyword">else</span>             j<span class="token operator">=</span> next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 若字符不相同，则j值回溯 */</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>主代码：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 返回子串T在主串S中第pos个字符之后的位置。若不存在，则函数返回值为0。 */</span><span class="token comment" spellcheck="true">/*  T非空，1≤pos≤StrLength(S)。 */</span><span class="token keyword">int</span> <span class="token function">Index_KMP</span><span class="token punctuation">(</span>String S<span class="token punctuation">,</span> String T<span class="token punctuation">,</span> <span class="token keyword">int</span> pos<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> pos<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* i用于主串S中当前位置下标值，若pos不为1，则从pos位置开始匹配 */</span>    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/* j用于子串T中当前位置下标值 */</span>    <span class="token keyword">int</span> next<span class="token punctuation">[</span><span class="token number">255</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 定义一next数组 */</span>    <span class="token function">get_next</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 对串T作分析，得到next数组 */</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> S<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">/* 若i小于S的长度并且j小于T的长度时，循环继续 */</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>j<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">||</span> S<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> T<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">/* 两字母相等则继续，与朴素算法增加了j=0判断 */</span>          <span class="token punctuation">{</span>             <span class="token operator">++</span>i<span class="token punctuation">;</span>             <span class="token operator">++</span>j<span class="token punctuation">;</span>           <span class="token punctuation">}</span>           <span class="token keyword">else</span>             <span class="token comment" spellcheck="true">/* 指针后退重新开始匹配 */</span>               j <span class="token operator">=</span> next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* j退回合适的位置，i值不变 */</span>        <span class="token comment" spellcheck="true">/**前面的朴素的是：        i=i-j+2; //返回i下一个位置        j=1; //j回到头               **/</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">></span> T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>         <span class="token keyword">return</span> i<span class="token operator">-</span>T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>         <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>其实相对于朴素算法来说，就是增加了得到next数组，和在两字母相等的时候的判断增加j==0的条件，和回头的时候，只是变化j为next[j]，而i不变</p><h2 id="5-7-4-KMP算法改进"><a href="#5-7-4-KMP算法改进" class="headerlink" title="5.7.4 KMP算法改进"></a>5.7.4 KMP算法改进</h2><h3 id="1-KMP算法还存在什么缺陷呢？"><a href="#1-KMP算法还存在什么缺陷呢？" class="headerlink" title="1.KMP算法还存在什么缺陷呢？"></a>1.KMP算法还存在什么缺陷呢？</h3><p>主要是当字符串出现重复的字符的时候，会出现重复回溯的情况</p><p>例子：</p><p>如果我们的主串S=”aaaabcde”，子串T=”aaaax”，其next数组值分别为012345，</p><p><img src="https://i.loli.net/2019/10/13/dTDk63mKNGz1wUf.jpg" alt></p><p>在开始时，当 i=5、j=5时，我们发现”b”与”a”不相等，如图5-7-6的①，因此j=next[5]=4，如图中的②，此时”b”与第4位置的”a”依然不等，j=next[4}=3。如图中的③，接着依次是④⑤，直到j=next[i]=0时，根据算法，此时i++、j++，得到i=6、j=l如图中的⑥。</p><p>我们发现，当中的②③④⑤步骤，其实是多余的判断</p><p><strong>怎么解决呢？</strong></p><p>由于T串的第二、三、四、五位置的字符<strong>都与首位的 “a” 相等</strong>，那么可以用首位 next[l]的值去<strong>取代与它相等的字符</strong>后续next[j]的值，这是个很好的办法。因此我们对求next函数进行了改良，改良后的叫nextval。</p><p>这就是nextval的由来了</p><h3 id><a href="#" class="headerlink" title></a></h3><h2 id="5-7-5-nextval数组值推导"><a href="#5-7-5-nextval数组值推导" class="headerlink" title="5.7.5 nextval数组值推导"></a>5.7.5 nextval数组值推导</h2><blockquote><p>举例子来说明比较简单</p></blockquote><h3 id="1-T-”ababaaaba”"><a href="#1-T-”ababaaaba”" class="headerlink" title="1. T=”ababaaaba”"></a>1. T=”ababaaaba”</h3><p><img src="https://s2.ax1x.com/2019/10/13/uv6ddH.png" alt="uv6ddH.png"></p><ul><li>1)当j=1时。nextval[1]=0;</li><li>2)当j=2时，因第二位字符”b”的next值是1，而第一位就是”a”，他们不相等，所以nextval[2]=next[2]=1，维持原值。</li><li>3)当j=3时，因为第三位字符”a”的next值为1，所以与第一位的”a”比较得知它们相等，所以nextval[3]=nextval[1]=0；如图5-7-7所示。</li></ul><p><a href="https://imgchr.com/i/uvclnS" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/10/13/uvclnS.png" alt="uvclnS.png"></a></p><ul><li><p>4)当j=4时，第四位的字符”b”，next值为2，所以与第二位的”b”相比较得到结果是相等，因此nextval[4]=nextval[2]=1；如图5-7-8所示。</p></li><li><p>5)当j=5时，next值为3，第五个字符”a”与第三个字符”a”相等，因此nextval[5]=nextval[3]=0;</p></li><li><p>6)当j=6时，next值为4，第六个字符”a”与第四个字符”b”不相等，因此nextval[6]=4;</p></li><li><p>7)当j=7时，next值为2，第七个字符”a”与第二个字符”b”不相等，因此nextval[7]=2;</p></li><li><p>8)当j=8时，next值为2，第八个字符”b”与第二个字符”b”相等，因此nextval[8]=nextval[2]=1;</p></li><li><p>9)当j=9时，next值为3，第九个字符”a”与第三个字符”a”相等，因此nextval[9]=nextval[3]=1。</p></li></ul><h3 id="2-T-”aaaaaaaab”（如表5-7-6）"><a href="#2-T-”aaaaaaaab”（如表5-7-6）" class="headerlink" title="2.T=”aaaaaaaab”（如表5-7-6）"></a>2.T=”aaaaaaaab”（如表5-7-6）</h3><p><img src="https://s2.ax1x.com/2019/10/13/uvg4x0.png" alt="uvg4x0.png"></p><ul><li>1)当j=1时，nextval[1]=0;</li><li>2)当j=2时，next值为1，第二个字符与第一个字符相等，所以nextval[2]=nextval[1]=0;</li><li>3)同样的道理，其后都为0….;</li><li>4)当j=9时，next值为8，第九个字符”b”与第八个字符”a”不相等，所以nextval[9]=8。</li></ul><h3 id="3-总结改进的kmp算法："><a href="#3-总结改进的kmp算法：" class="headerlink" title="3.总结改进的kmp算法："></a>3.总结改进的kmp算法：</h3><p>其实思路：</p><p>就是比较j位置的字符和next[j]位置的字符是否相等，如果相等的话，就nextval [ j ] = nextval [ next [ j ] ];他们的nextval值也相等</p><h3 id="4-nextval-算法揭秘"><a href="#4-nextval-算法揭秘" class="headerlink" title="4.nextval 算法揭秘"></a>4.nextval 算法揭秘</h3><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 求模式串T的next函数修正值并存入数组nextval */</span><span class="token keyword">void</span> <span class="token function">get_nextval</span><span class="token punctuation">(</span>String T<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>nextval<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">;</span>      i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>      j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>      nextval<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">&lt;</span>T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">/* 此处T[0]表示串T的长度 */</span>     <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">||</span> T<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span> T<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">/* T[i]表示后缀的单个字符，T[j]表示前缀的单个字符 */</span>        <span class="token punctuation">{</span>              <span class="token operator">++</span>i<span class="token punctuation">;</span>              <span class="token operator">++</span>j<span class="token punctuation">;</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span>T<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>T<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">/* 若当前字符与前缀字符不同*/</span>                nextval<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 则当前的j为nextval在i位置的值*/</span>               <span class="token keyword">else</span>                 nextval<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nextval<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 如果与前缀字符相同，则将前缀字符的 */</span>                                            <span class="token comment" spellcheck="true">/* nextval值赋值给nextval在i位置的值 */</span>        <span class="token punctuation">}</span>         <span class="token keyword">else</span>             j<span class="token operator">=</span> nextval<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/* 若字符不相同，则j值回溯 */</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>使用的时候，只需要将”get_next(T,next)”;改为”get_nextval(T,next);”即可</p>]]></content>
      
      
      <categories>
          
          <category> 大话数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大话数据结构 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.6 朴素的模式匹配算法</title>
      <link href="/2019/10/13/5.6-po-su-de-mo-shi-pi-pei-suan-fa/"/>
      <url>/2019/10/13/5.6-po-su-de-mo-shi-pi-pei-suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="5-6-朴素的模式匹配算法"><a href="#5-6-朴素的模式匹配算法" class="headerlink" title="5.6 朴素的模式匹配算法"></a>5.6 朴素的模式匹配算法</h1><blockquote><p>这个算法有什么用呢？</p><p>比如你想查找字符串的位置，就需要用到这个算法</p></blockquote><h2 id="1-什么是朴素的模式匹配算法"><a href="#1-什么是朴素的模式匹配算法" class="headerlink" title="1.什么是朴素的模式匹配算法"></a>1.什么是朴素的模式匹配算法</h2><p>简单来说<strong>就是对主串的每一个字符作为子串开头，与要匹配的字符串进行匹配。对主串做大循环，每个字符开头做T的长度的小循环，直到匹配成功或全部遍历完成为止</strong>。</p><p>还是用图来说明比较简单：</p><p>现在，从下面的主串S=”goodgoogle”中，找到T=”google”这个子串的位置。我们通常需要下面的步骤：</p><p>注意，其中竖直连线表示相等，闪电状弯折连线表示不等</p><ol><li><p>主串S第一位开始，S与T前三个字母都匹配成功，但S第四个字母是d而T的是g。第一位匹配失败。</p><p><img src="https://i.loli.net/2019/10/13/3KMzpI6ctjwXESo.jpg" alt></p></li><li><p>主串S第二位开始，主串S首字母是o，要匹配的T首字母是g，匹配失败</p><p><img src="https://i.loli.net/2019/10/13/GrlwjKY8SkNMFTi.jpg" alt></p></li><li><p>主串S第三位开始，主串S首字母是o，要匹配的T首字母是g，匹配失败，</p><p><img src="https://i.loli.net/2019/10/13/28VIfAWbUvjnHXz.jpg" alt></p></li><li><p>主串S第四位开始，主串S首字母是d，要匹配的T首字母是g，匹配失败</p><p><img src="https://i.loli.net/2019/10/13/FrLMTcJnPZap2j7.jpg" alt></p></li><li><p>主串S第五位开始，S与T，6个字母全匹配，匹配成功</p><p><img src="https://i.loli.net/2019/10/13/1kKD5MP6BAeGTub.jpg" alt></p></li></ol><h2 id="2-算法是怎么写的？"><a href="#2-算法是怎么写的？" class="headerlink" title="2.算法是怎么写的？"></a>2.算法是怎么写的？</h2><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 返回子串T在主串S中第pos个字符之后的起始位置。若不存在,则函数返回值为0。 */</span><span class="token comment" spellcheck="true">/* 其中,T非空,1≤pos≤StrLength(S)。 */</span><span class="token keyword">int</span> <span class="token function">Index</span><span class="token punctuation">(</span>String S<span class="token punctuation">,</span> String T<span class="token punctuation">,</span> <span class="token keyword">int</span> pos<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> pos<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* i用于主串S中当前位置下标值，若pos不为1，则从pos位置开始匹配 */</span>    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">/* j用于子串T中当前位置下标值 */</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> S<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">/* 若i小于S的长度并且j小于T的长度时，循环继续 */</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>S<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> T<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">/* 两字母相等则继续 */</span>          <span class="token punctuation">{</span>            <span class="token operator">++</span>i<span class="token punctuation">;</span>             <span class="token operator">++</span>j<span class="token punctuation">;</span>           <span class="token punctuation">}</span>           <span class="token keyword">else</span>                 <span class="token comment" spellcheck="true">/* 指针后退重新开始匹配 */</span>          <span class="token punctuation">{</span>               i <span class="token operator">=</span> i<span class="token operator">-</span>j<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* i退回到上次匹配首位的下一位 */</span>             j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">/* j退回到子串T的首位 */</span>          <span class="token punctuation">}</span>          <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">></span> T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>         <span class="token comment" spellcheck="true">//通过主串的位置-子串的长度，得到子串在主串中的起始位置</span>        <span class="token keyword">return</span> i<span class="token operator">-</span>T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>         <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="3-有什么缺点呢？"><a href="#3-有什么缺点呢？" class="headerlink" title="3.有什么缺点呢？"></a>3.有什么缺点呢？</h2><p>就是每次不成功的匹配都发生在子串的最后一个字符的话，这样就会造成很大的性能浪费</p><p>主串S=“00000000000000000001”，子串是“0001”</p>]]></content>
      
      
      <categories>
          
          <category> 大话数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大话数据结构 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.5 串的存储结构</title>
      <link href="/2019/10/13/5.5-chuan-de-cun-chu-jie-gou/"/>
      <url>/2019/10/13/5.5-chuan-de-cun-chu-jie-gou/</url>
      
        <content type="html"><![CDATA[<h1 id="5-5-串的存储结构"><a href="#5-5-串的存储结构" class="headerlink" title="5.5 串的存储结构"></a>5.5 串的存储结构</h1><h2 id="5-5-1-顺序存储"><a href="#5-5-1-顺序存储" class="headerlink" title="5.5.1 顺序存储"></a>5.5.1 顺序存储</h2><h3 id="1-串的顺序存储与普通的顺序存储（数组）有什么区别？"><a href="#1-串的顺序存储与普通的顺序存储（数组）有什么区别？" class="headerlink" title="1.串的顺序存储与普通的顺序存储（数组）有什么区别？"></a>1.串的顺序存储与普通的顺序存储（数组）有什么区别？</h3><p>由于串需要一些特殊的操作：比如说replace，有可能新的长度超过了原来的长度，所以他的存储空间可以由程序执行过程中动态分配而得到，不是一直固定的。</p><h2 id="5-5-2-串的链式存储"><a href="#5-5-2-串的链式存储" class="headerlink" title="5.5.2 串的链式存储"></a>5.5.2 串的链式存储</h2><h3 id="1-串的链式存储与链表有什么不同？"><a href="#1-串的链式存储与链表有什么不同？" class="headerlink" title="1.串的链式存储与链表有什么不同？"></a>1.串的链式存储与链表有什么不同？</h3><p>串的链式存储，一个结点可以存放1个字符，或者多个字符，如果最后一个结点没有放满的话，就用＃或者其他非串值字符补全，</p><h3 id="2-为啥这样呢？"><a href="#2-为啥这样呢？" class="headerlink" title="2.为啥这样呢？"></a>2.为啥这样呢？</h3><p>节省空间</p><h3 id="3-怎么决定一个结点放多少个字符呢？"><a href="#3-怎么决定一个结点放多少个字符呢？" class="headerlink" title="3.怎么决定一个结点放多少个字符呢？"></a>3.怎么决定一个结点放多少个字符呢？</h3><p>根据实际情况决定</p><h3 id="4-它和顺序存储哪个比较优秀呢？"><a href="#4-它和顺序存储哪个比较优秀呢？" class="headerlink" title="4.它和顺序存储哪个比较优秀呢？"></a>4.它和顺序存储哪个比较优秀呢？</h3><p>链式存储的优点：连接串和串的操作方便</p><p>缺点：灵活性不及顺序存储，性能不及顺序存储</p>]]></content>
      
      
      <categories>
          
          <category> 大话数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大话数据结构 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.10 队列的定义</title>
      <link href="/2019/10/13/4.10-dui-lie-de-ding-yi/"/>
      <url>/2019/10/13/4.10-dui-lie-de-ding-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="4-10-队列的定义"><a href="#4-10-队列的定义" class="headerlink" title="4.10 队列的定义"></a>4.10 队列的定义</h1><h2 id="1-什么是队列呢"><a href="#1-什么是队列呢" class="headerlink" title="1.什么是队列呢"></a>1.什么是队列呢</h2><p>队列是只允许在一端进行插入的操作，在另一端删除的线性表</p><h2 id="2-什么是队头，什么是队尾呢"><a href="#2-什么是队头，什么是队尾呢" class="headerlink" title="2.什么是队头，什么是队尾呢"></a>2.什么是队头，什么是队尾呢</h2><p>队尾就是允许插入的一端，队头就是允许删除的一端，类似于排队，排队要从后面排起来</p><h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
      
      
      <categories>
          
          <category> 大话数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大话数据结构 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.3 串的比较</title>
      <link href="/2019/10/13/5.3-chuan-de-bi-jiao/"/>
      <url>/2019/10/13/5.3-chuan-de-bi-jiao/</url>
      
        <content type="html"><![CDATA[<h1 id="5-3-串的比较"><a href="#5-3-串的比较" class="headerlink" title="5.3 串的比较"></a>5.3 串的比较</h1><h2 id="1-怎么进行串的比较呢？"><a href="#1-怎么进行串的比较呢？" class="headerlink" title="1.怎么进行串的比较呢？"></a>1.怎么进行串的比较呢？</h2><p>举例子：</p><ol><li><p>“hap”&lt;”hapa”，因为“”hapa”前面3个字母已经包含了”hap”,可以简单理解为：儿子的年龄肯定没有父亲的大</p></li><li><p>”hpaaa“&lt;”hpb”,因为前2个字母均相同，但是”hpb“第3个字母是b,”hpaaa“第3个字母是a，b&gt;a，所以”hpb”&gt;”hpaaa”，</p><p>可以简单理解为：不是父子关系的，看父亲（前面的字母），拼爹，只要你父亲厉害，无论你后面有多大努力（多长），都是白费（比不过）</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 大话数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大话数据结构 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.2 排序的基本概念和分类</title>
      <link href="/2019/10/11/9.2-pai-xu-de-ji-ben-gai-nian-he-fen-lei/"/>
      <url>/2019/10/11/9.2-pai-xu-de-ji-ben-gai-nian-he-fen-lei/</url>
      
        <content type="html"><![CDATA[<h1 id="9-2-排序的基本概念和分类"><a href="#9-2-排序的基本概念和分类" class="headerlink" title="9.2 排序的基本概念和分类"></a>9.2 排序的基本概念和分类</h1><h2 id="9-2-1-排序的稳定性怎么区分"><a href="#9-2-1-排序的稳定性怎么区分" class="headerlink" title="9.2.1 排序的稳定性怎么区分"></a>9.2.1 排序的稳定性怎么区分</h2><p>同分的时候，前后不变是稳定的，反之是不稳定的</p><h2 id="9-2-2-内排序和外排序"><a href="#9-2-2-内排序和外排序" class="headerlink" title="9.2.2 内排序和外排序"></a>9.2.2 内排序和外排序</h2><p>什么是内排序呢</p><p>其实就是所有记录都是放在内存中</p><p>什么是外排序呢</p><p>其实就是不能同时放在内存中，必须在内外存中多次交换数据</p>]]></content>
      
      
      <categories>
          
          <category> 大话数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大话数据结构 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.3 冒泡排序</title>
      <link href="/2019/10/11/9.3-mou-pao-pai-xu/"/>
      <url>/2019/10/11/9.3-mou-pao-pai-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="9-3-冒泡排序"><a href="#9-3-冒泡排序" class="headerlink" title="9.3 冒泡排序"></a>9.3 冒泡排序</h1><h2 id="9-3-1-什么是冒泡排序，最简单的冒泡排序"><a href="#9-3-1-什么是冒泡排序，最简单的冒泡排序" class="headerlink" title="9.3.1.什么是冒泡排序，最简单的冒泡排序"></a>9.3.1.什么是冒泡排序，最简单的冒泡排序</h2><p>其实就是两两比较相邻记录的关键字，如果反序就交换，直到没有反序</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 对顺序表L作交换排序（冒泡排序初级版） */</span><span class="token keyword">void</span> <span class="token function">BubbleSort0</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>L<span class="token operator">-></span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>L<span class="token operator">-></span>length<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token operator">-></span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>L<span class="token operator">-></span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                 <span class="token function">swap</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 交换L->r[i]与L->r[j]的值 */</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这个算法其实不是真正的冒泡，他是让每个关键字都和后面的每个比较，而且它只对排序的关键字有效，对未排序的没有帮助</p><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="9-3-2-冒泡排序算法"><a href="#9-3-2-冒泡排序算法" class="headerlink" title="9.3.2 冒泡排序算法"></a>9.3.2 冒泡排序算法</h2><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 对顺序表L作冒泡排序 */</span><span class="token keyword">void</span> <span class="token function">BubbleSort</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>L<span class="token operator">-></span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>L<span class="token operator">-></span>length<span class="token number">-1</span><span class="token punctuation">;</span>j<span class="token operator">>=</span>i<span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">/* 注意j是从后往前循环 */</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token operator">-></span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>L<span class="token operator">-></span>r<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">/* 若前者大于后者（注意这里与上一算法的差异）*/</span>            <span class="token punctuation">{</span>                 <span class="token function">swap</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span>j<span class="token punctuation">,</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 交换L->r[j]与L->r[j+1]的值 */</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>它对排序的关键字有效，对未排序的也有帮助</p><h2 id="9-3-3-冒泡排序优化"><a href="#9-3-3-冒泡排序优化" class="headerlink" title="9.3.3 冒泡排序优化"></a>9.3.3 冒泡排序优化</h2><p>如果是已经有序了的话，就不用进行后面的循环继续，增加1个flag就行</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 对顺序表L作改进冒泡算法 */</span><span class="token keyword">void</span> <span class="token function">BubbleSort2</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">;</span>    Status flag<span class="token operator">=</span>TRUE<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/* flag用来作为标记 */</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>L<span class="token operator">-></span>length <span class="token operator">&amp;&amp;</span> flag<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">/* 若flag为true说明有过数据交换，否则停止循环 */</span>    <span class="token punctuation">{</span>        flag<span class="token operator">=</span>FALSE<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">/* 初始为False */</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>L<span class="token operator">-></span>length<span class="token number">-1</span><span class="token punctuation">;</span>j<span class="token operator">>=</span>i<span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token operator">-></span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>L<span class="token operator">-></span>r<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                 <span class="token function">swap</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span>j<span class="token punctuation">,</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 交换L->r[j]与L->r[j+1]的值 */</span>                 flag<span class="token operator">=</span>TRUE<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 如果有数据交换，则flag为true */</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="-1"><a href="#-1" class="headerlink" title></a></h2><h2 id="9-3-4-冒泡排序复杂度是多少"><a href="#9-3-4-冒泡排序复杂度是多少" class="headerlink" title="9.3.4 冒泡排序复杂度是多少"></a>9.3.4 冒泡排序复杂度是多少</h2><p>其实就是O(n2)</p>]]></content>
      
      
      <categories>
          
          <category> 大话数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大话数据结构 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
